<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//FR">
<html>
<head>
<title>Annexe 1 - Les valeurs</title>
<meta http-equiv="content-type" content="text/html;CHARSET=iso-8859-15">
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="expires" content="-1"> 
<META NAME="KEYWORDS" CONTENT="REBOL, rebel, distributed computing, X Internet, X-Internet, xnet, executable internet, distributed applications, distributed platform, internet platform, internet programming, client-side computing, distributed desktop, platform independent, system independent, machine independent, operating system, programming language, scripting language, scripting, messaging, dialect, dialecting, e-content, direct Internet delivery, command">
<META NAME="Description" CONTENT="REBOL Technologies provides advanced, system-independent communication technology for the X Internet.">
<title>Annexe 1 - Les valeurs</title>
<style type="text/css">

body, p, td {font-family: arial, sans-serif, helvetica; font-size: 9pt;}

tt {font-family: "courier new", monospace, courier; font-size: 9pt;}
.title {Font-Size: 16 pt; Font-Weight: bold;}

/* style du header présentant le doc */
.header { padding: 10pt; padding-left: 20pt; margin-right: 30pt; width:"660px"; background-color: #e5e5e5; 
font-family: arial, sans-serif, helvetica; font-size: 9pt; font-weight: normal;}

/*  Le style du lien pour remonter à la Table des Matières  */
.top { font-size:8pt; text-align: right; color: #872C2C; width: 100%; }
/*  Le style des Notes  */
.note {
	margin: 1em 2em;
	padding: 1em;
	width: 85%;
	color: white;
	background-color: #B16C62;
	border: solid gray 1px;
	text-align:justify;
}
/*  Les styles des items de la table des matières  */
.toc1 {margin-left: 1cm; font-size: 10pt; font-weight: bold;}
.toc2 {margin-left: 2cm; font-size: 9pt; font-weight: bold; text-decoration: none;}
.toc3 {margin-left: 3cm; font-size: 8pt; text-decoration: none;}
.toc4 {margin-left: 4cm; font-size: 8pt; color: grey; text-decoration: none;}


h1 {font-size: 12pt;}
h2 {font-size: 10pt; color: #2030a0; width: 100%; border-bottom: 1px solid #c09060;}
h3 {font-size: 10pt; color: #2030a0;}
h4 {font-size: 9pt; color: #2030a0; font-weight: bold;}
h5 {font-size: 9pt; font-weight: bold;}

/*  Les styles du code et des outputs  */
pre {font: bold 9pt "courier new", monospace, console; color: #000000;
    background-color: #e0e0e0; padding: 16px; border: solid #a0a0a0 1px;}
.output {color: #000080; font-weight: normal;}

/*  Les styles des tableaux  */
.md-table table {font-family: verdana, arial, sans-serif, helvetica; 
border: solid black 1px;}

.md-header td {font-family: verdana, arial, sans-serif, helvetica; 
border: solid black 1px; background-color: silver;
font: bold 8pt; color: black; text-align: center;}

.md-cell td {font-family: verdana, arial, sans-serif, helvetica; 
border: solid #454545 1px;
font-size: 8pt; color: black; text-align: top}

/* style de la mention finale */
.tail {color: gray; font-size: 8pt;}

</style>
</head>
<body bgcolor="white"><h4 id="top" >&nbsp;</h4>
<center>
<table width="660" cellpadding="4" cellspacing="0" border="0">
<tr>
<td>
<a href="http://www.rebol.com/docs.html">
<img src="http://www.rebol.com/graphics/doc-bar.gif" width="680" height="28" align="bottom" alt="rebol document" border="0" usemap="#bar-map" ismap>
</a>
</td>

</tr>
<tr height="10"><td></td></tr>
<tr><td>
<p><h1 class="title" >Annexe 1 - Les valeurs</h1>
<div class="header">
Ce document est la traduction française de l'Annexe 1 du User Guide de REBOL/Core,<br />qui concerne les Valeurs.
</div>




<h2 class="toc-title" >Contenu </h2>
<a class="toc1" href="fr-rebolcore-a1.html#section-1">1. Historique de la traduction</a><br />
<a class="toc1" href="fr-rebolcore-a1.html#section-2">2. Valeurs relatives aux nombres</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-2.1">2.1 Decimal</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.1.1">2.1.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.1.2">2.1.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.1.3">2.1.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.1.4">2.1.4 Infos connexes</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-2.2">2.2 Integer</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.2.1">2.2.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.2.2">2.2.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.2.3">2.2.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-2.2.4">2.2.4 Infos connexes</a><br />
<a class="toc1" href="fr-rebolcore-a1.html#section-3">3. Valeurs relatives aux séries</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.1">3.1 Binary</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.1.1">3.1.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.1.2">3.1.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.1.3">3.1.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.1.4">3.1.4 Infos supplémentaires</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.2">3.2 Block</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.2.1">3.2.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.2.2">3.2.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.2.3">3.2.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.2.4">3.2.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.3">3.3 Email</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.3.1">3.3.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.3.2">3.3.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.3.3">3.3.3 Raffinements</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.3.4">3.3.4 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.3.5">3.3.5 Autres Informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.4">3.4 File</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.4.1">3.4.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.4.2">3.4.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.4.3">3.4.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.4.4">3.4.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.5">3.5 Hash</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.5.1">3.5.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.5.2">3.5.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.5.3">3.5.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.5.4">3.5.4 Autres infos</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.6">3.6 Image</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.6.1">3.6.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.6.2">3.6.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.6.3">3.6.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.6.4">3.6.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.7">3.7 Issue</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.7.1">3.7.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.7.2">3.7.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.7.3">3.7.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.7.4">3.7.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.8">3.8 List</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.8.1">3.8.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.8.2">3.8.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.8.3">3.8.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.8.4">3.8.4 Informations complémentaires</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.9">3.9 Paren</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.9.1">3.9.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.9.2">3.9.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.9.3">3.9.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.9.4">3.9.4 En plus</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.10">3.10 Path</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.10.1">3.10.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.10.2">3.10.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.10.3">3.10.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.10.4">3.10.4 Informations complémentaires</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.11">3.11 String</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.11.1">3.11.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.11.2">3.11.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.11.3">3.11.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.11.4">3.11.4 Informations connexes</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.12">3.12 Tag</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.12.1">3.12.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.12.2">3.12.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.12.3">3.12.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.12.4">3.12.4 Autres infos</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-3.13">3.13 URL</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.13.1">3.13.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.13.2">3.13.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.13.3">3.13.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-3.13.4">3.13.4 Autres infos</a><br />
<a class="toc1" href="fr-rebolcore-a1.html#section-4">4. Autres valeurs</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.1">4.1 Character</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.1.1">4.1.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.1.2">4.1.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.1.3">4.1.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.1.4">4.1.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.2">4.2 Date</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.2.1">4.2.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.2.2">4.2.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.2.3">4.2.3 Accéder aux données d'une variable date!</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.2.4">4.2.4 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.2.5">4.2.5 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.3">4.3 Logic</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.3.1">4.3.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.3.2">4.3.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.3.3">4.3.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.3.4">4.3.4 Informations complémentaires</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.4">4.4 Money</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.4.1">4.4.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.4.2">4.4.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.4.3">4.4.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.4.4">4.4.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.5">4.5 None</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.5.1">4.5.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.5.2">4.5.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.5.3">4.5.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.5.4">4.5.4 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.6">4.6 Pair</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.6.1">4.6.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.6.2">4.6.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.6.3">4.6.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.6.4">4.6.4 Autres</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.7">4.7 Raffinement</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.7.1">4.7.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.7.2">4.7.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.7.3">4.7.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.7.4">4.7.4 Et aussi...</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.8">4.8 Time</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.8.1">4.8.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.8.2">4.8.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.8.3">4.8.3 Accès aux champs</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.8.4">4.8.4 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.8.5">4.8.5 Autres informations</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.9">4.9 Tuple</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.9.1">4.9.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.9.2">4.9.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.9.3">4.9.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.9.4">4.9.4 Et aussi</a><br />
<a class="toc2" href="fr-rebolcore-a1.html#section-4.10">4.10 Words</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.10.1">4.10.1 Concept</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.10.2">4.10.2 Format</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.10.3">4.10.3 Création</a><br />
<a class="toc3" href="fr-rebolcore-a1.html#section-4.10.4">4.10.4 Autres informations</a><br />
<p>
<div class="top">[ <a href="#top">Retour au sommaire</a> ]</div>


<h2 id="section-1">1. Historique de la traduction</h2>
<blockquote>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Date</p>
</b></td><td><b>
<p>Version</p>
</b></td><td><b>
<p>Commentaires</p>
</b></td><td><b>
<p>Auteur</p>
</b></td><td><b>
<p>Email</p>
</td></tr><tr class="md-cell" ><td>
<p>18 Août 2005 21:02</p>
</td><td>
<p>1.0.0</p>
</td><td>
<p>Traduction initiale</p>
</td><td>
<p>Philippe Le Goff</p>
</td><td>
<p>lp--legoff--free--fr</p>
</td></tr></table>
<p>
</blockquote>
<p>
<div class="top">[ <a href="#top">Retour au sommaire</a> ]</div>


<h2 id="section-2">2. Valeurs relatives aux nombres</h2>
<blockquote>
</blockquote>
<p>
<h3 id="section-2.1">2.1 Decimal</h3>
<blockquote>
<p>
<h4 id="section-2.1.1">2.1.1 Concept</h4>
<p>Le type de données <b>decimal!</b> est basé sur le standard IEEE, c'est à dire des 
nombres sur 64 bits en virgule flottante. Ils se distinguent des nombres entiers 
via le séparateur décimal (un point, ou une virgule, peuvent être utilisés pour un usage international, voir les notes ci-dessous).</p>
<p>
<h4 id="section-2.1.2">2.1.2 Format</h4>
<p>Les valeurs décimales sont une séquence de chiffres numériques suivis par un point ou une virgule, 
puis encore d'autres chiffres.</p>
<p>Un signe (+) ou (-) présent immédiatement avant le premier chiffre indique le signe (positif ou négatif). 
Les zéros présents avant le séparateur des décimales sont ignorés. Les espaces, les points virgules et les points en trop 
ne sont pas autorisés.</p>
<pre>
1.23
123.
123.0
0.321
0.123
1234.5678
</pre>
<p>Une virgule (elle est la norme dans de nombreux pays) peut être utilisée au lieu d'un point pour représenter le séparateur décimal</p>
<pre>
1,23
0,321
1234,5678
</pre>
<p>Utilisez une apostrophe simple (`) pour séparer les chiffres dans les grands nombres décimaux. 
Les apostrophes simples peuvent apparaître après le premier chiffre dans le nombre, mais pas avant ce premier chiffre.</p>
<pre>
100'234'562.3782
100'234'562,3782
</pre>
<p>La notation scientifique peut être utilisée pour spécifier l'exposant d'un nombre 
en ajoutant au nombre la lettre E ou e suivie d'une série de chiffres. L'exposant peut être un 
nombre positif ou négatif.</p>
<pre>
1.23E10
1.2e007
123.45e-42
56,72E300
-0,34e-12
0.0001e-001
</pre>
<p>Les nombres décimaux s'étendent de 2.2250738585072e-308 jusqu'à 1.7976931348623e+308 
et peuvent avoir une précision sur 15 chiffres.</p>
<p>
<h4 id="section-2.1.3">2.1.3 Création</h4>
<p>Utilisez la fonction <b>to-decimal</b> pour convertir une 
chaîne de caractère (<b>string!</b>), un nombre entier (<b>integer!</b>), un bloc (<b>block!</b>), 
ou type de données <b>decimal!</b> en nombre décimal :</p>
<pre>
probe to-decimal "123.45"
<span class="output">123.45</span>
probe to-decimal 123
<span class="output">123</span>
probe to-decimal [-123 45]
<span class="output">-1.23E+47</span>
probe to-decimal [123 -45]
<span class="output">1.23E-43</span>
probe to-decimal -123.8
<span class="output">-123.8</span>
probe to-decimal 12.3
<span class="output">12.3</span>
</pre>
<p>Si un nombre décimal et un nombre entier sont combinés 
dans une expression, le nombre entier est converti en nombre décimal :</p>
<pre>
probe 1.2 + 2
<span class="output">3.2</span>
probe 2 + 1.2
<span class="output">3.2</span>
probe 1.01 &gt; 1
<span class="output">true</span>
probe 1 &gt; 1.01
<span class="output">false</span>
</pre>
<p>
<h4 id="section-2.1.4">2.1.4 Infos connexes</h4>
<p>Utilisez <b>decimal?</b> pour déterminer si une valeur est bien du type de données <b>decimal!</b> :</p>
<pre>
print decimal? 0.123
<span class="output">true</span>
</pre>
<p>Utilisez les fonctions <b>form</b>, <b>print</b> et <b>mold</b> avec un nombre en argument pour afficher la 
valeur décimale dans sa forme la plus réduite :</p>
<ul>
<li>entière s'il est possible de l'afficher ainsi.</li>
<li>décimal sans exposant s'il n'est pas trop grand ou trop petit.</li>
<li>en notation scientifique s'il est trop grand ou trop petit.</li>
</ul>
<p>Par exemple ,</p>
<pre>
probe mold 123.4
<span class="output">123.4</span>
probe form 2222222222222222
<span class="output">2.22222222222222E+15</span>
print 1.00001E+5
<span class="output">100001</span>
</pre>
<p>Les apostrophes simples (quotes) et un signe "plus" (+) précédant le nombre 
n'apparaissent pas dans l'affichage d'un décimal :</p>
<pre>
print +1'100'200.222'112
<span class="output">1100200.222112</span>
</pre>
</blockquote>
<p>
<h3 id="section-2.2">2.2 Integer</h3>
<blockquote>
<p>
<h4 id="section-2.2.1">2.2.1 Concept</h4>
<p>Le type de données <b>integer!</b> caractérise les nombres positifs et négatifs (et zéro) sur 32 bits. 
Contrairement aux nombres décimaux, les nombres entiers ne contiennent pas de décimales.</p>
<p>
<h4 id="section-2.2.2">2.2.2 Format</h4>
<p>Les valeurs entières consistent en une séquence de chiffres. Un signe plus (+) ou un signe 
moins (-) placé immédiatement avant le premier chiffre indique le signe. (Il ne peut y avoir 
d'espace entre le signe et le premier chiffre). Les zéros qui précédent le premier chiffre sont ignorés.</p>
<pre>
0 
1234 
+1234 
-1234 
00012 
-0123
</pre>
<p>N'utilisez pas de points, ni de virgules dans les entiers. 
Si une virgule ou un point est trouvé dans un entier, celui-ci sera interprété comme une valeur décimale. 
D'autre part, vous pouvez utilisez une apostrophe (`) pour séparer les chiffres dans les grands nombres 
entiers. Les apostrophes peuvent apparaître n'importe où après le premier chiffre dans le nombre, mais pas 
avant ce premier chiffre.</p>
<pre>
2'147'483'647
</pre>
<p>Les nombres entiers varient entre -2147483648 et 2147483647.</p>
<p>
<h4 id="section-2.2.3">2.2.3 Création</h4>
<p>Utilisez la fonction <b>to-integer</b> pour convertir un type de données <b>string!</b>, <b>logic!</b>, 
<b>decimal!</b>, ou <b>integer!</b> en un entier :</p>
<pre>
probe to-integer "123"
<span class="output">123</span>
probe to-integer false
<span class="output">0</span>
probe to-integer true
<span class="output">1</span>
probe to-integer 123.4
<span class="output">123</span>
probe to-integer 123.8
<span class="output">123</span>
probe to-integer -123.8
<span class="output">-123</span>
</pre>
<p>Si un décimal et un entier sont combinés dans une expression, 
le nombre entier sera converti en nombre décimal :</p>
<pre>
probe 1.2 + 2
<span class="output">3.2</span>
probe 2 + 1.2
<span class="output">3.2</span>
probe 1.01 &gt; 1
<span class="output">true</span>
probe 0 &lt; .001
<span class="output">true</span>
</pre>
<p>
<h4 id="section-2.2.4">2.2.4 Infos connexes</h4>
<p>Utilisez <b>integer?</b> pour déterminer si une valeur a pour type de données <b>integer!</b>.</p>
<pre>
probe integer? -1234
<span class="output">true</span>
</pre>
<p>Utilisez les fonctions <b>form</b>, <b>print</b> et <b>mold</b> avec un argument de type <b>integer!</b> pour 
afficher la valeur entière sous forme d'une chaîne de caractères :</p>
<pre>
probe mold 123
<span class="output">123</span>
probe form 123
<span class="output">123</span>
print 123
<span class="output">123</span>
</pre>
<p>Les entiers qui sont en dehors de l'intervalle décrit plus haut ou 
qui ne peuvent être représentés sur 32 bits générent une erreur.</p>
</blockquote>
<p>
<div class="top">[ <a href="#top">Retour au sommaire</a> ]</div>


<h2 id="section-3">3. Valeurs relatives aux séries</h2>
<blockquote>
</blockquote>
<p>
<h3 id="section-3.1">3.1 Binary</h3>
<blockquote>
<p>
<h4 id="section-3.1.1">3.1.1 Concept</h4>
<p>Les valeurs binaires comprennent arbitrairement des données binaires de n'importe quel type.
N'importe quelle séquence d'octets peut être stockée, comme une image, un son, un fichier exécutable, 
des données compressées, et des données cryptées.</p>
<p>
<h4 id="section-3.1.2">3.1.2 Format</h4>
<p>Les chaînes binaires sont écrites sous la forme d'un signe (#) dièse, 
suivi d'une chaîne de caractères incluse entre deux accolades. Les caractères 
au sein de la chaîne sont encodés dans l'un des divers formats comme l'indique le nombre (optionnel) 
qui précède le signe (#).</p>
<p>Le codage en base 16 (hexadécimal) est le format par défaut.</p>
<pre>
#{3A18427F 899AEFD8} ; default base-16
2#{10010110110010101001011011001011} ; base-2
64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz934b} ; base-64
</pre>
<p>Les espaces, les tabulations et les sauts de lignes sont autorisés 
dans la chaîne. Une donnée binaire peut s'étendre sur plusieurs lignes.</p>
<pre>
probe #{
    3A
    18
    92
    56
}
<span class="output">#{3A189256}</span>
</pre>
<p>Les chaînes de caractères, pour lesquelles manquent des caractères permettant de retrouver 
un résultat binaire correct, sont décalées sur la droite (au niveau des  bits).</p>
<p>
<h4 id="section-3.1.3">3.1.3 Création</h4>
<p>La fonction <b>to-binary</b> convertit des données dans le type <b>binary!</b>, avec l'encodage existant par 
défaut dans <b>system/options/binary-base</b> :</p>
<pre>
probe to-binary "123"
<span class="output">#{313233}</span>
probe to-binary "today is the day..."
<span class="output">#{746F64617920697320746865206461792E2E2E}</span>
</pre>
<p>Pour convertir un nombre entier en son équivalent en valeur binaire, mettez-le dans un bloc :</p>
<pre>
probe to-binary [1]
<span class="output">#{01}</span>
probe to-binary [11]
<span class="output">#{0B}</span>
</pre>
<p>La conversion d'une série de nombres entiers en binaire se fait par la conversion 
de chacun des entiers, et en concaténant l'ensemble en une seule valeur binaire :</p>
<pre>
probe to-binary [1 1 1 1]
<span class="output">#{01010101}</span>
</pre>
<p>
<h4 id="section-3.1.4">3.1.4 Infos supplémentaires</h4>
<p>L'usage de la fonction <b>binary?</b> permet de déterminer si une valeur est de type 
de données <b>binary!</b>.</p>
<pre>
probe binary? #{616263}
<span class="output">true</span>
</pre>
<p>Les valeurs binaires font partie du type <b>series!</b> :</p>
<pre>
probe series? #{616263}
<span class="output">true</span>
probe length? #{616263} ; three hex values in this binary
<span class="output">3</span>
</pre>
<p>Les fonctions <b>enbase</b> et <b>debase</b> sont très importantes dans la manipulation des 
valeurs de type <b>binary!</b>. <br>La fonction <b>enbase</b> convertit des chaînes en leur représentation en base-2, 
en base 16 ou en base 64. La fonction <b>debase</b> transforme des chaînes codées en une valeur binaire, en utilisant 
la base numérique spécifiée dans  <b>system/options/binary-base</b>.</p>
</blockquote>
<p>
<h3 id="section-3.2">3.2 Block</h3>
<blockquote>
<p>
<h4 id="section-3.2.1">3.2.1 Concept</h4>
<p>Les blocs sont des groupes de valeurs et de mots. Les blocs sont utilisés partout, comme depuis un script lui-même 
jusqu'aux blocs de données et de code fournis dans le script. Les valeurs de type <b>block</b> sont indiquées 
avec des crochets ouvrants et fermants ([ ]) et une quantité variable de datas contenues entre eux.</p>
<pre>
[123 data "hi"]  ; bloc avec des datas
[]               ; bloc vide
</pre>
<p>Les blocs peuvent permettre de manipuler des enregistrements :</p>
<pre>
woodsmen: [
    "Paul" "Bunyan" paul@bunyan.dom
    "Grizzly" "Adams" grizzly@adams.dom
    "Davy" "Crocket" davy@crocket.dom
]
</pre>
<p>Les blocs peuvent contenir du code :</p>
<pre>
[print "this is a segment of code"]
</pre>
<p>Les blocs sont également rattachés au type <b>series!</b>, et tout ce qui peut être réalisé avec une série 
peut l'être aussi avec un bloc.</p>
<p>Il est possible d'effectuer des recherches dans des blocs :</p>
<pre>
probe copy/part (find woodsmen "Grizzly") 3
<span class="output">[
    "Grizzly" "Adams" grizzly@adams.dom]</span>
</pre>
<p>Les blocs peuvent être modifiés :</p>
<pre>
append woodsmen [
    "John" "Muir" john@muir.dom
]
probe woodsmen
<span class="output">[
    "Paul" "Bunyan" paul@bunyan.dom 
    "Grizzly" "Adams" grizzly@adams.dom 
    "Davy" "Crocket" davy@crocket.dom 
    "John" "Muir" john@muir.dom
]</span>
</pre>
<p>Les blocs peuvent être évalués :</p>
<pre>
blk: [print "data in a block"]
do blk
<span class="output">data in a block</span>
</pre>
<p>Les blocs peuvent contenir d'autres blocs :</p>
<pre>
blks: [
    [print "block one"]
    [print "block two"]
    [print "block three"]
]
foreach blk blks [do blk]
<span class="output">block one
block two
block three</span>
</pre>
<p>
<h4 id="section-3.2.2">3.2.2 Format</h4>
<p>Les blocs peuvent contenir un nombre variable de valeurs ou aucune valeur. 
Ils peuvent s'étendre sur plusieurs lignes et peuvent inclure n'importe quel type de valeurs, 
y compris d'autres blocs.</p>
<p>Un bloc vide :</p>
<pre>
[ ]
</pre>
<p>Un bloc de nombres entiers :</p>
<pre>
[24 37 108]
</pre>
<p>Un en-tête (header) REBOL :</p>
<pre>
REBOL [
    Title: "Test Script"
    Date: 31-Dec-1998
    Author: "Ima User"
]
</pre>
<p>Un bloc conditionnel et un bloc évalué d'une fonction :</p>
<pre>
while [time &lt; 10:00] [
    print time
    time: time + 0:10
]
</pre>
<p>Les mots dans un bloc ont besoin d'être définis :</p>
<pre>
blk: [undefined words in a block]
probe value? pick blk 1
<span class="output">false</span>
</pre>
<p>Les blocs autorisent n'importe quel nombre de lignes, d'espaces, ou de tabulations. 
Les lignes et les espaces peuvent être placés n'importe où au sein du bloc, tant qu'ils ne segmentent pas des valeurs.</p>
<p>
<h4 id="section-3.2.3">3.2.3 Création</h4>
<p>La fonction <b>to-block</b> convertit une data en une valeur de type de données <b>block!</b> :</p>
<pre>
probe to-block luke@rebol.com
<span class="output">[luke@rebol.com]</span>
probe to-block {123 10:30 "string" luke@rebol.com}
<span class="output">[123 10:30 "string" luke@rebol.com]</span>
</pre>
<p>
<h4 id="section-3.2.4">3.2.4 Autres informations</h4>
<p>Utilisez  <b>block?</b> pour déterminer si une valeur est ou non du datatype <b>block!</b> .</p>
<pre>
probe block? [123 10:30]
<span class="output">true</span>
</pre>
<p>Les blocs étant un sous-ensemble du pseudo type <b>series!</b>, vous pouvez utilisez <b>series?</b> pour vérifier qu'un bloc est bien de ce type :</p>
<pre>
probe series? [123 10:30]
<span class="output">true</span>
</pre>
<p>L'usage de la fonction <b>form</b> sur une valeur de type <b>block !</b>  produit une chaîne de caractères à partir du contenu 
du bloc :</p>
<pre>
probe form [123 10:30]
<span class="output">123 10:30</span>
</pre>
<p>L'usage de la fonction <b>mold</b> sur une valeur de type block a pour effet, elle, de créer une chaîne de caractères avec 
le contenu du bloc, comme <b>form</b>, mais en permettant que le résultat soit récupérable sous forme d'un bloc REBOL :</p>
<pre>
probe mold [123 10:30]
<span class="output">[123 10:30]</span>
</pre>
<p>Les types de données <b>hash!</b> et <b>list!</b> sont très similaires au type <b>block!</b>. Ils sont utilisables de la même façon que les valeurs de 
type <b>block!</b> mais possèdent des caractéristiques particulières. Les valeurs de type <b>list!</b> sont conçues pour permettre des modifications de listes 
plus rapidement que les valeurs <b>block!</b>, et les valeurs de type <b>hash!</b> permettent de gérer des tris et l'indexation de données. Ils sont assez commodes 
lorsqu'on se sert de jeux de données importants.</p>
</blockquote>
<p>
<h3 id="section-3.3">3.3 Email</h3>
<blockquote>
<p>
<h4 id="section-3.3.1">3.3.1 Concept</h4>
<p>Une adresse email est un type de données. En REBOL, le type de données <b>email!</b> exprime facilement ce que représente des adresses email.</p>
<pre>
send luke@rebol.com {some message}

emails: [
    john@keats.dom
    lord@byron.dom
    edger@guest.dom
    alfred@tennyson.dom
]
mesg: {poetry reading at 8:00pm!}
foreach email emails [send email mesg]
</pre>
<p>Le type de données <b>email!</b> fait partie aussi du type <b>series!</b>, de sorte que les règles s'appliquant aux séries s'appliquent 
aussi aux valeurs de type <b>email!</b> :</p>
<pre>
probe head change/part jane@doe.dom "john" 4
<span class="output">john@doe.dom</span>
</pre>
<p>
<h4 id="section-3.3.2">3.3.2 Format</h4>
<p>Le format standard d'une adresse email est le suivant : un nom, suivi du symbole arobase (@), 
suivi d'un nom de domaine. Une adresse email peut être de n'importe quelle longueur, mais ne doit 
pas comprendre un seul caractère non autorisé comme les crochets, les apostrophes (quotes), les accolades, les espaces, 
les caractères de fin de ligne, etc.</p>
<p>Les valeurs suivantes ont un format valide pour le type de données <b>email!</b> :</p>
<pre>
info@rebol.com
123@number-mail.org
my-name.here@an.example-domain.com
</pre>
<p>Les caractères minuscules et majuscules sont conservés dans les adresses email.</p>
<p>
<h4 id="section-3.3.3">3.3.3 Raffinements</h4>
<p>Deux raffinements peuvent être utilisés avec une valeur <b>email!</b> pour récupérer le nom d'utilisateur ou le domaine. 
Ces raffinements sont :</p>
<table cellspacing="6" border="0" width="95%">
<tr><td width="20">&nbsp;</td><td valign="top" width="80"><b>/user</b></td><td valign="top">Récupère le nom d'utilisateur.
</td></tr>
<tr><td width="20">&nbsp;</td><td valign="top" width="80"><b>/host</b></td><td valign="top">Récupère le domaine.
</td></tr>
</table>
<p>Voici quelques illustrations du fonctionnement de ces raffinements :</p>
<pre>
email: luke@rebol.com
probe email/user
<span class="output">luke</span>
probe email/host
<span class="output">rebol.com</span>
</pre>
<p>
<h4 id="section-3.3.4">3.3.4 Création</h4>
<p>La fonction <b>to-email</b> transforme une donnée en une valeur de type <b>email!</b> :</p>
<pre>
probe to-email "info@rebol.com"
<span class="output">info@rebol.com</span>
probe to-email [info rebol.com]
<span class="output">info@rebol.com</span>
probe to-email [info rebol com]
<span class="output">info@rebol.com</span>
probe to-email [user some long domain name out there dom]
<span class="output">user@some.long.domain.name.out.there.dom</span>
</pre>
<p>
<h4 id="section-3.3.5">3.3.5 Autres Informations</h4>
<p>Utilisez la fonction <b>email?</b> pour déterminer si une valeur est de type <b>email!</b>.</p>
<pre>
probe email? luke@rebol.com
<span class="output">true</span>
</pre>
<p>Le type de donnée <b>email!</b> étant un sous-ensemble du type de donnée <b>series!</b>, vous pouvez aussi utilisez 
<b>series?</b> pour savoir si la valeur testée est une série :</p>
<pre>
probe series? luke@rebol.com
<span class="output">true</span>
probe pick luke@rebol.com 5
<span class="output">#"@"</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.4">3.4 File</h3>
<blockquote>
<p>
<h4 id="section-3.4.1">3.4.1 Concept</h4>
<p>Le type de données <b>file!</b> peut concerner un nom de fichier, un nom de répertoire ou un chemin complet 
dans une arborescence (path).</p>
<pre>
%file.txt
%directory/
%directory/path/to/some/file.txt
</pre>
<p>Les valeurs de type <b>file!</b> sont aussi des séries et peuvent être manipulées comme telles :</p>
<pre>
probe find %dir/path1/path2/file.txt "path2"
<span class="output">%path2/file.txt</span>
f: %dir/path/file.txt
probe head remove/part (find f "path/") (length? "path/")
<span class="output">%dir/file.txt</span>
</pre>
<p>
<h4 id="section-3.4.2">3.4.2 Format</h4>
<p>Les fichiers se caractérisent par un signe "pourcentage" (%) suivi par une suite de caractères :</p>
<pre>
load %image.jpg
prog: load %examples.r
save %this-file.txt "This file has few words."
files: load %../programs/
</pre>
<p>Les caractères "inhabituels" dans les noms de fichiers doivent être encodés avec leurs équivalents hexadécimaux selon 
la convention en vigueur sur Internet. Un nom de fichier avec un espace (en hexadécimal : %20) devrait ressembler à ceci :</p>
<pre>
probe %cool%20movie%20clip.mpg
<span class="output">%cool%20movie%20clip.mpg</span>
print %cool%20movie%20clip.mpg
<span class="output">cool movie clip.mpg</span>
</pre>
<p>Une autre possibilité est d'englober le nom de fichier entre deux apostrophes :</p>
<pre>
probe %"cool movie clip.mpg"
<span class="output">%cool%20movie%20clip.mpg</span>
print %"cool movie clip.mpg"
<span class="output">cool movie clip.mpg</span>
</pre>
<p>Le caractère standard pour séparer des répertoires dans un chemin est le caractère slash (/), et NON le backslash (\). 
Cependant, le langage REBOL transforme automatiquement les symboles backslash trouvés dans les noms de fichiers en caractères slash :</p>
<pre>
probe %\some\path\to\some\where\movieclip.mpg
<span class="output">%/some/path/to/some/where/movieclip.mpg</span>
</pre>
<p>
<h4 id="section-3.4.3">3.4.3 Création</h4>
<p>La fonction <b>to-file</b> transforme une donnée en une valeur de type de données <b>file!</b> :</p>
<pre>
probe to-file "testfile"
<span class="output">%testfile</span>
</pre>
<p>Lorsqu'un bloc est passé en argument à <b>to-file</b>, les éléments du bloc sont concaténés pour former un chemin de fichier, le dernier 
élément du bloc servant de nom de fichier :</p>
<pre>
probe to-file [some path to a file the-file.txt]
<span class="output">%some/path/to/a/file/the-file.txt</span>
</pre>
<p>
<h4 id="section-3.4.4">3.4.4 Autres informations</h4>
<p>Utilisez la fonction <b>file?</b> pour savoir si une valeur est de type <b>file!</b> :</p>
<pre>
probe file? %rebol.r
<span class="output">true</span>
</pre>
<p>Comme le type <b>file!</b> est un sous-ensemble de <b>series!</b>, la fonction <b>series?</b> est aussi utilisable :</p>
<pre>
probe series? %rebol.r
<span class="output">true</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.5">3.5 Hash</h3>
<blockquote>
<p>
<h4 id="section-3.5.1">3.5.1 Concept</h4>
<p>Un hash est un bloc présentant une organisation particulière afin d'y trouver très rapidement des données. 
Lorsqu'une recherche est réalisée sur une valeur de type <b>hash!</b>, celle-ci est réalisée en utilisant 
une indexation spécifique à la table, qui permet pour de grands blocs, d'accélèrer la recherche d'un facteur 100 et plus.</p>
<p>
<h4 id="section-3.5.2">3.5.2 Format</h4>
<p>Les blocs de type <b>hash!</b> doivent être construits en utilisant la fonction <b>make</b> ou la fonction <b>to-hash</b>. 
Il n'y a pas de format spécifique.</p>
<p>
<h4 id="section-3.5.3">3.5.3 Création</h4>
<p>Utilisez <b>make</b> pour initialiser un hash :</p>
<pre>
hsh: make hash! 10 ; alloue un espace pour 10 élements
</pre>
<p>La fonction <b>to-hash</b> transforme une donnée en une valeur de type <b>hash!</b>.</p>
<p>Transformer un bloc :</p>
<pre>
blk: [1 "one" 2 "two" 3 "three" 4 "four"]
probe hash: to-hash blk
<span class="output">make hash! [1 "one" 2 "two" 3 "three" 4 "four"]</span>
print select hash 2
<span class="output">two</span>
</pre>
<p>Transformer diverses valeurs  :</p>
<pre>
probe to-hash luke@rebol.com

probe to-hash 123.5

probe to-hash {123 10:30 "string" luke@rebol.com}
</pre>
<p>
<h4 id="section-3.5.4">3.5.4 Autres infos</h4>
<p>Utilisez <b>hash?</b> pour tester le type de données.</p>
<pre>
hsh: to-hash [1 "one" 2 "two" 3 "three" 4 "four"]
probe hash? Hsh
<span class="output">true</span>
</pre>
<p>Le type <b>hash!</b> étant un sous-ensemble du type <b>series!</b>, la fonction <b>series?</b> peut là encore être utilisée :</p>
<pre>
probe series? hsh
<span class="output">true</span>
</pre>
<p>L'usage de la fonction <b>form</b> sur une valeur de type hash renvoie une chaîne de caractères composée avec le contenu 
du hash :</p>
<pre>
probe form hsh
<span class="output">"1 one 2 two 3 three 4 four"</span>
</pre>
<p>Avec la fonction <b>mold</b>, on crée une chaîne de caractère avec la valeur hash et son contenu, mais celle-ci peut être 
récupérable sous forme d'une valeur de type hash pour REBOL :</p>
<pre>
probe mold hsh
<span class="output">make hash! [1 "one" 2 "two" 3 "three" 4 "four"]</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.6">3.6 Image</h3>
<blockquote>
<p>
<h4 id="section-3.6.1">3.6.1 Concept</h4>
<p>Le type de données <b>image!</b> permet la manipulation des images RGB. Ce datatype est utilisé avec REBOL/View. 
Les formats d'image supportés sont le GIF, le JPEG, et le BMP. Les images chargées en mémoire peuvent être manipulées 
comme des séries.</p>
<p>
<h4 id="section-3.6.2">3.6.2 Format</h4>
<p>Les images sont en principe chargées à partir d'un fichier. Cependant, elles peuvent être exprimées sous forme de code source, ou aussi 
fabriquées. L'exemple suivant illustre l'exemple d'une image exprimée sous forme d'un bloc incluant la taille de l'image et les données RGB.</p>
<pre>
image: make image! [192x144 #{
    B34533B44634B44634B54735B7473
    84836B84836B84836BA4837BA4837
    BC4837BC4837BC4837BC4837BC483 ...
}
</pre>
<p>
<h4 id="section-3.6.3">3.6.3 Création</h4>
<p>Des images "vides" peuvent être créées avec les fonctions <b>make</b> ou <b>to-image</b> :</p>
<pre>
empty-img: make image! 300x300
empty-img: to-image 150x300
</pre>
<p>La taille de l'image est fournie.</p>
<p>Les images peuvent aussi être créées avec des copies d'écran ou des objets de type <b>'face</b>. Par exemple, 
en utilisant <b>make</b> ou <b>to-image</b> :</p>
<pre>
face-shot: make image! face
face-shot: to-image face
</pre>
<p>Utilisez la fonction <b>load</b> pour charger en mémoire une image à partir d'un fichier. Si le format 
de l'image n'est pas supporté, le chargement n'aura pas lieu.</p>
<p>Pour charger en mémoire une image :</p>
<pre>
img: load %bay.jpg
</pre>
<p>
<h4 id="section-3.6.4">3.6.4 Autres informations</h4>
<p>Utilisez la fonction <b>image?</b> pour savoir si une valeur est ou non du type <b>image!</b> :</p>
<pre>
probe image? img
</pre>
<p>Les valeurs de type <b>image!</b> sont des séries :</p>
<pre>
probe &lt;b&gt;series?&lt;/b&gt; img
</pre>
<p>Le raffinement <b>/size</b> renvoie la taille de l'image sous la forme d'une valeur de type <b>pair!</b> :</p>
<pre>
probe img/size
</pre>
<p>Les valeurs des pixels d'une image sont obtenus en utilisant la fonction <b>pick</b> et 
modifiées avec <b>poke</b>. La valeur retournée par la fonction <b>pick</b> est un tuple RGB. (voir plus loin les tuples).
La valeur remplacée avec la fonction <b>poke</b> doit elle aussi être un tuple RGB.</p>
<p>Récupérer des pixels spécifiques :</p>
<pre>
probe pick img 1 

probe pick img 1500
</pre>
<p>Modifier des pixels particuliers :</p>
<pre>
poke img 1 255.255.255 
probe pick img 1 

poke img 1500 0.0.0 
probe pick img 1500
</pre>
</blockquote>
<p>
<h3 id="section-3.7">3.7 Issue</h3>
<blockquote>
<p>
<h4 id="section-3.7.1">3.7.1 Concept</h4>
<p>Une valeur de type <b>issue!</b> consiste en une série de caractères utilisés pour mettre en forme des choses comme des numéros de téléphones, 
des numéros de séries ou de modèles, des numéros de cartes de crédits.</p>
<p>Les valeurs de type <b>issue!</b> sont un sous-ensemble de celles de type <b>series!</b>, et peuvent être manipulées comme telles :</p>
<pre>
probe copy/part find #888-555-1212 "555" 3
<span class="output">#555</span>
</pre>
<p>
<h4 id="section-3.7.2">3.7.2 Format</h4>
<p>Les valeurs de type <b>issue!</b> commencent avec le signe dièse (#) et continuent avec une série de caractères jusqu'au premier  
caractère délimiteur (comme l'espace) trouvé.</p>
<pre>
#707-467-8000
#A-0987654321-CD-09876
#1234-5678-4321-8765
#MG82/32-7
</pre>
<p>Les valeurs qui contiennent des caractères délimiteurs devraient être écrites 
sous forme de chaînes de caractères plutôt que sous forme d'"issues".</p>
<p>
<h4 id="section-3.7.3">3.7.3 Création</h4>
<p>La fonction <b>to-issue</b> transforme une donnée en une valeur de datatype <b>issue!</b>.</p>
<pre>
probe to-issue "1234-56-7890"
<span class="output">#1234-56-7890</span>
</pre>
<p>
<h4 id="section-3.7.4">3.7.4 Autres informations</h4>
<p>Utilisez <b>issue?</b> pour savoir si une valeur est ou non du type de donnée <b>issue!</b>.</p>
<pre>
probe issue? #1234-56-7890
<span class="output">true</span>
</pre>
<p>Comme les valeurs "issues" sont un sous-ensemble de valeurs series, la fonction <b>series?</b> s'applique aussi :</p>
<pre>
probe series? #1234-56-7890
<span class="output">true</span>
</pre>
<p>La fonction <b>form</b> renvoie une chaîne de caractères constituée par la séquence de caractères de la valeur <b>issue!</b> 
mais sans le signe (#):</p>
<pre>
probe form #1234-56-7890
<span class="output">1234-56-7890</span>
</pre>
<p>La fonction <b>mold</b> s'utilise comme la fonction <b>form</b>, elle renvoie une chaîne pouvant être 
interprétée par REBOL comme une valeur <b>issue!</b> :</p>
<pre>
probe mold #1234-56-7890
<span class="output">#1234-56-7890</span>
</pre>
<p>La fonction <b>print</b> permet d'afficher une valeur de type <b>issue!</b> après un "<b>reform</b>" sur celle-ci :</p>
<pre>
print #1234-56-7890
<span class="output">1234-56-7890</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.8">3.8 List</h3>
<blockquote>
<p>
<h4 id="section-3.8.1">3.8.1 Concept</h4>
<p>Les listes sont des énumérations sous formes de blocs qui permettent des ajouts et des suppressions 
très efficaces en terme de performances. Elles peuvent être utilisables dans les cas où de nombreuses modifications sont à effectuer 
sur de grands volumes de données (grands blocs).</p>
<p>
<h4 id="section-3.8.2">3.8.2 Format</h4>
<p>Les listes doivent être construites en utilisant la fonction <b>make</b> ou la fonction <b>to-list</b>. 
Il n'y a pas de format lexical spécifique.</p>
<p>Les valeurs de type <b>list!</b> ne sont pas des subsituts aux valeurs <b>block!</b>.  Il existe quelques différences entre 
les blocs et les listes :</p>
<p>L'insertion dans une liste modifie son index, que se positionne juste après le point d'insertion.
La suppression d'un élément référencé dans une liste conduit à remettre à jour la position finale de la liste (tail).</p>
<p>Les exemples suivants montre la différence de comportement entre l'insertion dans un bloc et dans une liste.</p>
<p>Initialisation d'un bloc et d'une liste :</p>
<pre>
blk: [1 2 3]

lst: to-list [1 2 3]
</pre>
<p>Insertion dans un bloc et dans une liste :</p>
<pre>
insert blk 0

insert lst 0
</pre>
<p>Regardez le mot dans le bloc et dans la liste juste après l'insertion. Remarquez que 
le bloc blk pointe sur la tête du bloc (<b>head</b>), comme avant l'insertion de la valeur 0, mais 
la liste lst pointe sur la position juste <i>après</i> le point d'insertion :</p>
<pre>
print blk
<span class="output">0 1 2 3</span>
print lst
<span class="output">1 2 3</span>
print head lst
<span class="output">0 1 2 3</span>
</pre>
<p>Les exemples suivants montrent la différence entre un bloc et une liste, lors de la suppression d'un élément.</p>
<p>Initialisation du bloc et de la liste :</p>
<pre>
blk: [1 2 3]

lst: to-list [1 2 3]
</pre>
<p>Suppression au sein du bloc et de la liste :</p>
<pre>
remove blk

remove lst
</pre>
<p>Si on regarde l'état du bloc et de la liste, on constate qu'à présent 
la liste lst pointe sur la fin de la série (<b>tail</b>) :</p>
<pre>
print blk
<span class="output">2 3</span>
print tail? lst
<span class="output">true</span>
print head lst
<span class="output">2 3</span>
</pre>
<p>Si vous ne voulez pas pointer sur la fin de la série, après avoir supprimé une valeur, il 
convient de vous déplacer dans la série et d'enlever la valeur après l'index courant. 
L'exemple suivant illustre cela :</p>
<p>Initialisation de la liste :</p>
<pre>
lst: to-list [1 2 3]
</pre>
<p>Déplacement dans la série et suppression de la valeur après l'index courant :</p>
<pre>
remove back (lst: next lst)
</pre>
<p>Si on regarde à l'endroit où la valeur a été supprimée :</p>
<pre>
probe lst
<span class="output">make list! [2 3]</span>
print tail? lst
<span class="output">false</span>
</pre>
<p>
<h4 id="section-3.8.3">3.8.3 Création</h4>
<p>Il faut utiliser la fonction <b>make</b> pour initialiser une valeur de type <b>list!</b> :</p>
<pre>
lst: make list! 10 ; alloue de l'espace pour 10 éléments
</pre>
<p>La fonction <b>to-list</b> convertit son argument en une valeur de type de donnée <b>list!</b> :</p>
<p>Pour transformer un bloc :</p>
<pre>
blk: [1 "one" 2 "two" 3 "three" 4 "four"]
probe to-list blk
<span class="output">make list! [1 "one" 2 "two" 3 "three" 4 "four"]</span>
</pre>
<p>
<h4 id="section-3.8.4">3.8.4 Informations complémentaires</h4>
<p>Utilisez <b>list?</b> pour déterminer si une valeur est ou non du type de données <b>list!</b>.</p>
<pre>
lst: to-list [1 "one" 2 "two" 3 "three" 4 "four"]
probe list? Lst
<span class="output">true</span>
</pre>
<p>Puisque les listes sont aussi des séries, la fonction <b>series?</b> est aussi utile :</p>
<pre>
probe series? lst
<span class="output">true</span>
</pre>
<p>L'usage de la fonction <b>form</b> sur une liste génère une chaîne de caractères composée à partir du contenu de la liste :</p>
<pre>
probe form lst
<span class="output">"1 one 2 two 3 three 4 four"</span>
</pre>
<p>Avec la fonction <b>mold</b>, c'est presque comme pour <b>form</b>, si ce n'est que le résultat peut être immédiatement 
récupérable par REBOL sous forme d'une valeur <b>list!</b>  :</p>
<pre>
probe mold lst
make list! [1 "one" 2 "two" 3 "three" 4 "four"]
</pre>
</blockquote>
<p>
<h3 id="section-3.9">3.9 Paren</h3>
<blockquote>
<p>
<h4 id="section-3.9.1">3.9.1 Concept</h4>
<p>Une valeur de type <b>paren!</b> est un bloc (Ndt : avec usage de <b>paren</b>thèses) qui est immédiatement évalué. Cette valeur est en tous points identique à un bloc, 
à l'exception du fait qu'elle est évaluée lorsqu'elle est rencontrée, et que le résultat de l'évaluation est retourné. 
Lorsqu'on l'utilise à l'intérieur d'une expression à évaluer, une valeur de type <b>paren!</b> permet de contrôler l'ordre de 
l'évaluation.</p>
<pre>
print 1 + (2 * 3)
<span class="output">7</span>
print 1 + 2 * 3
<span class="output">9</span>
</pre>
<p>Comme pour un bloc, une valeur de type <b>paren!</b> peut être modifiée. 
Cependant, si on souhaite faire référence à cette valeur <b>paren!</b>, des précautions doivent être prises pour 
éviter qu'elle soit évaluée.</p>
<p>Si vous stockez une valeur <b>paren!</b> dans une variable, vous devrez utilisez la forme <b>get-word</b> (c'est-à-dire <b>:word</b>) pour 
prévenir une éventuelle évaluation. 
Les "parens" étant un sous-ensemble des séries, ce qui peut être fait avec une série est aussi possible avec une valeur <b>paren!</b>.</p>
<pre>
paren: first [(1 + 2 * 3 / 4)]
<span class="output">(1 + 2 * 3 / 4)</span>
print type? :paren
<span class="output">paren</span>
print length :paren
<span class="output">7</span>
print first :paren
<span class="output">1</span>
print last :paren
<span class="output">4</span>
insert :paren [10 + 5 *]
probe :paren
<span class="output">(10 + 5 * 1 + 2 * 3 / 4)</span>
print paren
<span class="output">12.75</span>
</pre>
<p>
<h4 id="section-3.9.2">3.9.2 Format</h4>
<p>Les valeurs de type <b>paren!</b> sont identifiées par des parenthèses ouvrantes et fermantes. 
Elles peuvent s'étendre sur plusieurs lignes et contenir n'importe quelle donnée, dont d'autres valeurs <b>paren!</b>.</p>
<p>
<h4 id="section-3.9.3">3.9.3 Création</h4>
<p>Le fonction <b>make</b> peut être utilisée pour définir une valeur <b>paren!</b> :</p>
<pre>
paren: make paren! 10
insert :paren 10
insert :paren `+
insert :paren 20

print :paren
<span class="output">20 + 10</span>
print paren
<span class="output">30</span>
</pre>
<p>La fonction <b>to-paren</b> transforme une donnée en une valeur de datatype <b>paren!</b> :</p>
<pre>
probe to-paren "123 456"
<span class="output">(123 456)</span>
probe to-paren [123 456]
<span class="output">(123 456)</span>
</pre>
<p>
<h4 id="section-3.9.4">3.9.4 En plus</h4>
<p>Utilisez <b>paren?</b> pour tester le type de la donnée.</p>
<pre>
blk: [(3 + 3)]
probe pick blk 1
<span class="output">(3 + 3)</span>
probe paren? pick blk 1
<span class="output">true</span>
</pre>
<p>Comme les <i>parens</i> sont un sous-ensemble de celui des séries, il est possible d'utiliser <b>series?</b> :</p>
<pre>
probe series? pick blk 1
<span class="output">true</span>
</pre>
<p>L'utilisation de <b>form</b> sur une valeur de type <b>paren!</b> crée une chaîne de caractères à partir 
du contenu de cette valeur :</p>
<pre>
probe form pick blk 1
3 + 3
</pre>
</blockquote>
<p>
<h3 id="section-3.10">3.10 Path</h3>
<blockquote>
<p>
<h4 id="section-3.10.1">3.10.1 Concept</h4>
<p>Les paths (<b>NdT</b> : on pourrait traduire par "chemins", l'idée générale étant d'avoir une valeur en REBOL qui 
traduit l'idée de se déplacer dans une arborescence, ou de préciser une particularité d'une fonction, par exemple) 
sont un ensemble de mots et de valeurs délimités par des slashs (/).</p>
<p>Les paths sont utilisés pour naviguer vers quelque chose, préciser ou trouver quelque chose.</p>
<p>Les mots et les valeurs d'un path sont appelés des raffinements, et ils sont assemblés pour donner une direction, 
un sens de "navigation"  au travers d'une valeur ou d'une fonction. 
Les paths sont utilisés avec les blocs, les fichiers, les chaînes de caractères, les listes, les hashs, 
les fonctions, et les objets.</p>
<p>La façon dont les paths agissent dépend du type de données avec lesquels ils sont utilisés.</p>
<p>Les paths peuvent être utilisés pour sélectionner des valeurs dans des blocs, ou des caractères dans 
une chaîne, accéder à des variables dans des objets, donner un comportement particulier à une fonction :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Type de path</p>
</b></td><td><b>
<p>Action</p>
</td></tr><tr class="md-cell" ><td>
<p>USA/CA/Ukiah/size</p>
</td><td>
<p>sélection dans un bloc</p>
</td></tr><tr class="md-cell" ><td>
<p>names/12</p>
</td><td>
<p>position dans une chaîne</p>
</td></tr><tr class="md-cell" ><td>
<p>account/balance</p>
</td><td>
<p>fonction dans un objet</p>
</td></tr><tr class="md-cell" ><td>
<p>match/any</p>
</td><td>
<p>raffinement d'une fonction</p>
</td></tr></table>
<p>
<p>L'exemple ci-dessous montre la simplicité d'usage qu'offre un path 
pour accéder aux informations d'une mini base de données créées à partir de quelques blocs :</p>
<pre>
towns: [
    Hopland [
    phone #555-1234
    web   http://www.hopland.ca.gov
    ]

    Ukiah [
    phone #555-4321
    web   http://www.ukiah.com
    email info@ukiah.com
    ]
]

print towns/ukiah/web
<span class="output">http://www.ukiah.com</span>
</pre>
<p>Résumé des concepts de paths :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Type de path</p>
</b></td><td><b>
<p>Type de mot</p>
</b></td><td><b>
<p>Type de Test</p>
</b></td><td><b>
<p>Fonction de conversion</p>
</td></tr><tr class="md-cell" ><td>
<p>path/word:</p>
</td><td>
<p>set-path!</p>
</td><td>
<p>set-path?</p>
</td><td>
<p>to-set-path</p>
</td></tr><tr class="md-cell" ><td>
<p>path/word</p>
</td><td>
<p>path!</p>
</td><td>
<p>path?</p>
</td><td>
<p>to-path</p>
</td></tr><tr class="md-cell" ><td>
<p>'path/word</p>
</td><td>
<p>lit-path!</p>
</td><td>
<p>lit-path?</p>
</td><td>
<p>to-lit-path</p>
</td></tr></table>
<p>
<p><b><u>Exemples de paths</u></b> :</p>
<p>Pour évaluer une fonction (une méthode) liée à un objet :</p>
<pre>
obj: make object! [
    hello: func [] [print "hello! hello!"]
]
obj/hello
<span class="output">hello! hello!</span>
</pre>
<p>Pour évaluer un attribut d'un objet :</p>
<pre>
obj: make object! [
    text: "do you believe in magic?"
]
probe obj/text
<span class="output">do you believe in magic?</span>
</pre>
<p>Des raffinements de fonction :</p>
<pre>
hello: func [/again] [
    print either again ["hello again!"]["hello"]
]
<span class="output">hello/again
hello again!</span>
</pre>
<p>Pour effectuer une sélection à partir de blocs :</p>
<pre>
USA: [
    CA [
    Ukiah [
        population 15050
        elevation [610 feet]
    ]
    Willits [
        population 5073
        elevation [1350 feet]
    ]
    ]
]
print USA/CA/Ukiah/population
<span class="output">15050</span>
print form USA/CA/Willits/elevation
<span class="output">1350 feet</span>
</pre>
<p>Pour récupérer des élements à partir d'une série, via leur position numérique dans celle-ci :</p>
<pre>
string-series: "abcdefg"
block-series: ["John" 21 "Jake" 32 "Jackson" 43 "Joe" 52]
block-with-sub-series: [ "abc" [4 5 6 [7 8 9]]]
probe string-series/4
<span class="output">#"d"</span>
probe block-series/3
<span class="output">Jake</span>
probe block-series/6
<span class="output">43</span>
probe block-with-sub-series/1/2
<span class="output">#"b"</span>
probe block-with-sub-series/2/2
<span class="output">5</span>
probe block-with-sub-series/2/4/2
<span class="output">8</span>
</pre>
<p>Les mots fournis en tant que paths sont symboliques, et par conséquent ne sont pas évalués. 
Ceci permet de construire la forme la plus intuitive pour référencer un objet.</p>
<p>Pour utiliser la référence au mot, une référence explicite à la valeur du mot est requise :</p>
<pre>
city: 'Ukiah
probe USA/CA/:city     ; &lt;&lt; :city fait ici référence à 'Ukiah
<span class="output">[
    population 15050 
    elevation "610 feet"
]</span>
</pre>
<p>Les chemins dans les blocs, les hashs, ou les objets sont évalués en 
utilisant la correspondance avec le mot au plus haut niveau dans le path, et 
en vérifiant si le mot est de type <b>block!</b>, <b>hash!</b> ou <b>object!</b>.
Ensuite le mot suivant est recherché en tant que mot présent dans le bloc, le 
hash ou l'objet, et une sélection se fait. La valeur qui suit le mot recherché est renvoyée.
Quand la valeur retournée est un bloc, un hash, ou un objet, le path peut être exprimé ainsi :</p>
<p>Récupération de la valeur associée au mot CA dans USA :</p>
<pre>
probe USA/CA
<span class="output">[
    Ukiah [
    population 15050 
    elevation "610 feet"
    ] 
    Willits [
    population 9935 
    elevation "1350 feet"
    ]
]</span>
</pre>
<p>Récupération de la valeur associée avec Willits dans USA/CA :</p>
<pre>
probe USA/CA/Willits
<span class="output">[
    population 9935 
    elevation "1350 feet"
]</span>
</pre>
<p>Récupération de la valeur associée au mot "population" dans USA/CA/Willits :</p>
<pre>
probe USA/CA/Willits/population
<span class="output">9935</span>
</pre>
<p>Quand un mot utilisé dans un path n'existe pas à un endroit donné de la stucture, 
une erreur se produit :</p>
<pre>
probe USA/CA/Mendocino
<span class="output">** Script Error: Invalid path value: Mendocino.
** Where: probe USA/CA/Mendocino</span>
</pre>
<p>Les paths peuvent être utilisés pour modifier des valeurs dans des 
blocs et des objets :</p>
<pre>
USA/CA/Willits/elevation: "1 foot, after the earthquake"
probe USA/CA/Willits
<span class="output">[
    population 9935 
    elevation "1 foot, after the earthquake"
]</span>
obj/text: "yes, I do believe in magic."
probe obj
<span class="output">make object! [
    text: "yes, I do believe in magic."
]</span>
</pre>
<p>Les blocs, les hashs, les fonctions et les objets peuvent 
être mélangés dans les paths.</p>
<p>Pour choisir des éléments dans un bloc, lui-même dans un objet :</p>
<pre>
obj: make object! [
    USA: [
    CA [
        population "too many"
    ]
    ]
]
probe obj/USA/CA/population
<span class="output">too many</span>
</pre>
<p>Utilisation de raffinements de fonctions au sein d'un objet :</p>
<pre>
obj: make object! [
    hello: func [/again] [
    print either again [
        "hello again"
    ] [
        "oh, hello"
    ]
    ]
]
<span class="output">obj/hello/again
hello again</span>
</pre>
<p>Les paths sont aussi des séries, de sorte que ce qui peut être réalisé avec une série peut 
aussi l'être avec une valeur de type <b>path!</b> :</p>
<pre>
root: [sub1 [sub2 [
    word "a word at the end of the path"
    num 55
]   ]   ]
path: 'root/sub1/sub2/word
probe :path
<span class="output">root/sub1/sub2/word</span>
</pre>
<p>Dans l'exemple précédent, la notation :path a été utilisée pour récupérer le path lui-même, 
et non sa valeur :</p>
<pre>
probe path
<span class="output">a word at the end of the path</span>
</pre>
<p>Pour connaître la longueur d'un path :</p>
<pre>
probe length? :path
<span class="output">4</span>
</pre>
<p>Trouver un mot à l'intérieur d'un path :</p>
<pre>
probe find :path 'sub2
<span class="output">sub2/word</span>
</pre>
<p>Modifier un mot dans un path :</p>
<pre>
change find :path 'word 'num
probe :path
<span class="output">root/sub1/sub2/num</span>
probe path
<span class="output">55</span>
</pre>
<p>
<h4 id="section-3.10.2">3.10.2 Format</h4>
<p>Les paths sont exprimés relativement à un mot-racine, en fournissant un certain nombre de 
raffinements, chacun étant séparé des autres par le symbole slash (/).</p>
<p>Ces raffinements peuvent être des mots ou des valeurs. Leur interprétation particulière 
dépend du type de données du mot situé à la racine.</p>
<p>Les mots fournis comme raffinement dans les paths sont symboliques et ne sont pas évalués. 
Ceci est nécessaire pour garder une forme de référencement assez intuitive. 
Pour utilisez la référence d'un mot, une référence explicite est nécessaire comme vu précédemment :</p>
<pre>
root/:word
</pre>
<p>Cet exemple utilise la valeur de la variable, plutôt 
que son nom.</p>
<p>
<h4 id="section-3.10.3">3.10.3 Création</h4>
<p>Vous pouvez créer un path vierge d'une taille donnée comme dans l'exemple suivant :</p>
<pre>
path: make path! 10
insert :path `test
insert tail :path `this
print :path
<span class="output">test/this</span>
</pre>
<p>La fonction <b>to-path</b> transforme son argument en une valeur de type <b>path!</b>.</p>
<pre>
probe to-path [root sub]
<span class="output">root/sub</span>
probe to-path "root sub"
<span class="output">root/sub</span>
</pre>
<p>La fonction <b>to-set-path</b> convertit des valeurs en type <b>set-word</b> (mot défini) :</p>
<pre>
probe to-set-path "root sub"
root/sub:
</pre>
<p>La fonction <b>to-lit-path</b> convertit des valeurs en type <b>lit-word</b> (mot litéral):</p>
<pre>
probe to-lit-path "root sub"
'root/sub
</pre>
<p>
<h4 id="section-3.10.4">3.10.4 Informations complémentaires</h4>
<p>Utilisez <b>path?</b>, <b>set-path?</b>, et <b>lit-path?</b> pour déterminer le type de données d'une valeur.</p>
<pre>
probe path? second [1 two "3"]
<span class="output">false</span>
blk: [sub1 [sub2 [word 1]]]
blk2: [blk/sub1/sub2/word: 2]
if set-path? (pick blk2 1) [print "it is set"]
<span class="output">it is set</span>
probe lit-path? first ['root/sub]
<span class="output">true</span>
</pre>
<p>Comme les paths sont un sous-ensemble du pseudo type <b>series!</b>, la fonction <b>series?</b> peut également être utilisée :</p>
<pre>
probe series? pick [root/sub] 1
true
</pre>
<p>L'application de la fonction <b>form</b> sur un path génére une chaîne de 
caractères à partir du path :</p>
<pre>
probe form pick [root/sub] 1
root/sub
</pre>
<p>Avec la fonction <b>mold</b>, on crée aussi une chaîne de caractère comme pour <b>form</b>, 
mais celle-ci peut être rechargée sous forme d'un path REBOL :</p>
<pre>
probe mold pick [root/sub] 1
root/sub
</pre>
</blockquote>
<p>
<h3 id="section-3.11">3.11 String</h3>
<blockquote>
<p>
<h4 id="section-3.11.1">3.11.1 Concept</h4>
<p>Les chaînes (strings) sont des séries de caractères. Toutes les opérations possibles sur les valeurs de type 
série peuvent également être faites avec des chaînes de caractère.</p>
<p>
<h4 id="section-3.11.2">3.11.2 Format</h4>
<p>Les valeurs de type <b>string!</b> se présentent sous la forme d'une séquence de caractères entourés par des 
apostrophes " " ou des accolades {}. Les chaînes incluses entre des apostrophes sont limitées à une unique ligne, 
et ne peuvent contenir certains caractères non imprimables.</p>
<pre>
"This is a short string of characters."
</pre>
<p>Les chaînes comprises entre accolades sont utilisées pour de grands morceaux de texte, pouvant s'étaler 
sur plusieurs lignes. 
Tous les caractères de la chaîne, comme les espaces, les tabulations, les apostrophes, et les sauts de 
ligne font partie de la chaîne.</p>
<pre>
{This is a long string of text that will 
not easily fit on a single line of source.
These are often used for documentation
purposes.}
</pre>
<p>Les accolades sont comptées dans la chaîne, de sorte qu'une chaîne de 
caractères peut inclure d'autres accolades à condition que le nombre 
d'accolades ouvrantes soit identique au nombre d'accolades fermantes.</p>
<pre>
{
This is another long string of text that would
never fit on a single line. This string also
includes braces { a few layers deep { and is 
valid because there are as many closing braces }
as there are open braces } in the string.
}
</pre>
<p>Vous pouvez inclure des caractères spéciaux et effectuer certaines opérations dans les 
chaînes de caractères en préfixant ces caractères spéciaux par le symbole (^) :</p>
<p>Inclusion de caractères spéciaux :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Caractère</p>
</b></td><td><b>
<p>Définition</p>
</td></tr><tr class="md-cell" ><td>
<p>^"</p>
</td><td>
<p>Insère une double quote (").</p>
</td></tr><tr class="md-cell" ><td>
<p>^}</p>
</td><td>
<p>Insère une accolade fermante (}).</p>
</td></tr><tr class="md-cell" ><td>
<p>^^</p>
</td><td>
<p>Insère le symbole <i>caret</i> (^).</p>
</td></tr><tr class="md-cell" ><td>
<p>^/</p>
</td><td>
<p>Insère le symbole slash</p>
</td></tr><tr class="md-cell" ><td>
<p>^(line)</p>
</td><td>
<p>Débute une nouvelle ligne.</p>
</td></tr><tr class="md-cell" ><td>
<p>^-</p>
</td><td>
<p>Insère une tabulation.</p>
</td></tr><tr class="md-cell" ><td>
<p>^(tab)</p>
</td><td>
<p>Insère aussi une tabulation.</p>
</td></tr><tr class="md-cell" ><td>
<p>^(page)</p>
</td><td>
<p>Démarre une nouvelle page</p>
</td></tr><tr class="md-cell" ><td>
<p>^(back)</p>
</td><td>
<p>Efface un caractère à gauche du point d'insertion.</p>
</td></tr><tr class="md-cell" ><td>
<p>^(null)</p>
</td><td>
<p>Insère le caractère "null".</p>
</td></tr><tr class="md-cell" ><td>
<p>^(escape)</p>
</td><td>
<p>Insère le caractère "escape".</p>
</td></tr><tr class="md-cell" ><td>
<p>^(letter)</p>
</td><td>
<p>Insère un caractère de contrôle (A-Z).</p>
</td></tr><tr class="md-cell" ><td>
<p>^(xx)</p>
</td><td>
<p>Insère un caractère ASCII via son équivalent hexadécimal (xx). Ce format permettra 
une extension pour les caractères Unicode dans le futur.</p>
</td></tr></table>
<p>
<p>
<h4 id="section-3.11.3">3.11.3 Création</h4>
<p>Utilisez <b>make</b> pour allouer une quantité d'espace mémoire 
pour une chaîne de caractères vide :</p>
<pre>
make string! 40'000 ; espace pour 40k (caractères)
</pre>
<p>La fonction <b>to-string</b> transforme le type de la donnée fournie en argument, en type de donnée <b>string!</b>.</p>
<pre>
probe to-string 29-2-2000
<span class="output">"29-Feb-2000"</span>
probe to-string 123456.789
<span class="output">"123456.789"</span>
probe to-string #888-555-2341
<span class="output">"888-555-2341"</span>
</pre>
<p>Transformer un bloc de données en une chaîne, avec la fonction <b>to-string</b>, a pour 
conséquence de concaténer les élements du bloc, mais sans les évaluer :</p>
<pre>
probe to-string [123 456]
<span class="output">"123456"</span>
probe to-string [225.225.225.0 none true 'word]
<span class="output">"225.225.225.0nonetrueword"</span>
</pre>
<p>
<h4 id="section-3.11.4">3.11.4 Informations connexes</h4>
<p>Utilisez <b>string?</b> ou <b>series?</b> pour déterminer si une valeur 
est de type <b>string!</b> :</p>
<pre>
print string? "123"
<span class="output">true</span>
print series? "123"
<span class="output">true</span>
</pre>
<p>Les fonctions <b>form</b> et <b>mold</b> sont fortement corrélées aux chaînes, dans le sens 
où elles génèrent des chaînes de caractères à partir de données d'autres types. 
La fonction <b>form</b> permet l'obtention d'une forme humainement lisible d'un type de 
donnée spécifique, tandis que la fonction <b>mold</b> fabrique une version utilisable par le langage.</p>
<pre>
probe form "111 222 333"
<span class="output">"111 222 333"</span>
probe mold "111 222 333"
<span class="output">{"111 222 333"}</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.12">3.12 Tag</h3>
<blockquote>
<p>
<h4 id="section-3.12.1">3.12.1 Concept</h4>
<p>Les tags (balises) sont utilisés dans les langages à balises pour indiquer comment des zones 
de texte doivent être traitées. Par exemple, le tag &lt;HTML&gt; au début d'un fichier 
indique qu'il devrait être analysé au moyen des régles du langage HTML.</p>
<p>Une balise avec un slash (/), tel que &lt;/HTML&gt; indique la fermeture du tag.</p>
<p>Les tags, en tant que sous-ensemble des séries peuvent être manipulés comme tels :</p>
<pre>
a-tag: &lt;img src="mypic.jpg"&gt;
probe a-tag
<span class="output">&lt;img src="mypic.jpg"&gt;</span>
append a-tag { alt="My Picture!"}
probe a-tag
<span class="output">&lt;img src="mypic.jpg" alt="My Picture!"&gt;</span>
</pre>
<p>
<h4 id="section-3.12.2">3.12.2 Format</h4>
<p>Les tags valides commencent par le symbole (&lt;) et se termine avec (&gt;).</p>
<p>Par exemple :</p>
<pre>
&lt;a href="index.html"&gt;
&lt;img src="mypic.jpg" width="150" height="200"&gt;
</pre>
<p>
<h4 id="section-3.12.3">3.12.3 Création</h4>
<p>La fonction <b>to-tag</b> convertit une donnée en une autre de type <b>tag!</b> :</p>
<pre>
probe to-tag "title"
<span class="output">&lt;title&gt;</span>
</pre>
<p>Vous pouvez utiliser la fonction <b>build-tag</b> pour construire des tags, et y inclure des 
attributs. La fonction  <b>build-tag</b> prend un seul argument, un bloc. 
Dans ce bloc, le premier mot est utilisé pour nommer le tag, et les mots suivants servent 
à définir des paires d'attributs :</p>
<pre>
probe build-tag [a href http://www.rebol.com/]
<span class="output">&lt;a href="http://www.rebol.com/"&gt;</span>
probe build-tag [
    img src %mypic.jpg width 150 alt "My Picture!"
]
<span class="output">&lt;img src="mypic.jpg" width="150" alt="My Picture!"&gt;</span>
</pre>
<p>
<h4 id="section-3.12.4">3.12.4 Autres infos</h4>
<p>L'usage de la fonction <b>tag?</b> permet de déterminer si une valeur 
est bien de type de données <b>tag!</b> .</p>
<pre>
probe tag? &lt;a href="http://www.rebol.com/"&gt;
<span class="output">true</span>
</pre>
<p>Comme les tags sont aussi des séries, la fonction <b>series?</b> peut être appelée :</p>
<pre>
probe series? &lt;a href="http://www.rebol.com/"&gt;
<span class="output">true</span>
</pre>
<p>La fonction <b>form</b> renvoie le tag qui lui est fourni, sous la forme d'une chaîne :</p>
<pre>
probe form &lt;a href="http://www.rebol.com/"&gt;
<span class="output">{&lt;a href="http://www.rebol.com/"&gt;}</span>
</pre>
<p>La fonction <b>mold</b> renvoie elle aussi une chaîne :</p>
<pre>
probe mold &lt;a href="http://www.rebol.com/"&gt;
<span class="output">{&lt;a href="http://www.rebol.com/"&gt;}</span>
</pre>
<p>La fonction <b>print</b> affiche un tag sur la sortie standard :</p>
<pre>
print &lt;a href="http://www.rebol.com/"&gt;
<span class="output">&lt;a href="http://www.rebol.com/"&gt;</span>
</pre>
</blockquote>
<p>
<h3 id="section-3.13">3.13 URL</h3>
<blockquote>
<p>
<h4 id="section-3.13.1">3.13.1 Concept</h4>
<p>Le terme "URL" est l'acronyme de Uniform Ressource Locator, un standard Internet utilisé 
pour accéder à des ressources comme des pages Web, des images, des fichiers, et du 
courrier électronique au travers du réseau.</p>
<p>Le type d'URL la plus connue est celle utilisée pour le Web comme http://www.rebol.com.
Les valeurs URLs sont des séries, et peuvent être manipulées comme telles :</p>
<pre>
url: http://www.rebol.com/reboldoc.html
probe to-file find/reverse (tail url) "rebol"
<span class="output">%reboldoc.html</span>
</pre>
<p>
<h4 id="section-3.13.2">3.13.2 Format</h4>
<p>La première partie d'un URL indique son protocole de communication, appelé le "scheme". 
Le langage REBOL supporte plusieurs types de protocoles, pour les pages web  (HTTP:), 
le transfert de fichier (FTP:), les newsgroups (NNTP:), le courrier électronique (MAILTO:), les fichiers (FILE:), 
finger (FINGER:), whois (WHOIS:), daytime (DAYTIME:), post office  (POP:), 
le protocole de transmission (TCP:) et celui de résolution des noms de domaines (DNS:). 
Ces noms de protocoles, ces "schemes" sont suivis dans l'URL par une série de caractères dépend ant 
du protocole utilisé :</p>
<pre>
http://host.dom/path/file
ftp://host.dom/path/file
nntp://news.some-isp.net/some.news.group
mailto:name@domain
file://host/path/file
finger://user@host.dom
whois://rebol@rs.internic.net
daytime://everest.cclabs.missouri.edu
pop://user:passwd@host.dom/
tcp://host.dom:21
dns://host.dom
</pre>
<p>Certains champs sont optionnels. Par exemple, le nom d'hôte peut être suivi par un numéro 
de port, si ce dernier est différent de celui par défaut. Une URL FTP peut aussi comprendre un
mot de passe :</p>
<pre>
ftp://user:password@host.dom/path/file
</pre>
<p>Les caractères dans l'URL doivent respectés les conventions Internet. 
Certains caractères doivent être encodés en hexadécimal, en les faisant 
précéder du caractère d'échappement "%" :</p>
<pre>
probe http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt
<span class="output">http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt</span>
print http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt
<span class="output">http://www.somesite.dom/odd(dir)/odd{file}.txt</span>
</pre>
<p>
<h4 id="section-3.13.3">3.13.3 Création</h4>
<p>La fonction <B>to-url</B> transforme un bloc en une valeur de type <B>url!</B>, 
le premier élément dans le bloc est le "scheme", le second élement est le domaine 
(avec ou sans user:pass et le port), les éléments suivants sont le path et le nom du fichier.</p>
<pre>
probe to-url [http www.rebol.com reboldoc.html]
<span class="output">http://www.rebol.com/reboldoc.html</span>
probe to-url [http www.rebol.com %examples "websend.r"]
<span class="output">http://www.rebol.com/examples/websend.r</span>
probe to-url [http usr:pass@host.com:80 "(path)" %index.html]
<span class="output">http://usr:pass@host.com:80/%28path%29/index.html</span>
</pre>
<p>
<h4 id="section-3.13.4">3.13.4 Autres infos</h4>
<p>La fonction <B>url?</B> permet de tester si le type de données est bien <B>url!</B>.</p>
<pre>
probe url? ftp://ftp.rebol.com/
<span class="output">true</span>
</pre>
<p>La fonction <b>series?</b> est également utilisable pour vérifier le type de données.</p>
<pre>
probe series? http://www.rebol.com/
<span class="output">true</span>
</pre>
</blockquote>
<p>
<div class="top">[ <a href="#top">Retour au sommaire</a> ]</div>


<h2 id="section-4">4. Autres valeurs</h2>
<blockquote>
</blockquote>
<p>
<h3 id="section-4.1">4.1 Character</h3>
<blockquote>
<p>
<h4 id="section-4.1.1">4.1.1 Concept</h4>
<p>Les caractères ne sont pas des chaînes (strings); ce sont les valeurs unitaires à partir desquelles 
les chaînes sont construites. 
Un caractère peut être imprimable, non imprimable, ou encore être un caractère de contrôle.</p>
<p>
<h4 id="section-4.1.2">4.1.2 Format</h4>
<p>Une valeur <b>char!</b> est écrite avec le signe dièse (#) suivi par une chaîne comprise entre deux 
apostrophes.</p>
<p>Le signe (#) est nécessaire pour distinguer un caractère d'une chaîne :</p>
<ul>
<li>#"R"    ; le caractère : R</li>
<li>"R"     ; une chaîne de caractère a un seul caractère : R</li>
</ul>
<p>Les caractères peuvent inclure des séquences d'échappement, qui commence avec le symbole (^) et 
sont suivis par un ou plusieurs caractères. Cette codification va inclure les caractères 
#"^A" to #"^Z", c'est-à-dire du "contrôle A" au "contrôle Z" (majuscule et minuscule sont identiques).</p>
<pre>
#"^A" #"^Z"
</pre>
<p>De plus, si des parenthèses sont utilisées au sein du caractère, elles signifient 
qu'il s'agit d'une valeur spéciale. Par exemple, le caractère "nul" peut être écrit ainsi :</p>
<pre>
"^@"
"^(null)"
"^(00)"
</pre>
<p>La dernière ligne est écrite en format hexadécimale (base 16). Les parenthèses 
autour de la valeur permettent de prévoir l'extension en Unicode (16 bits) du type char! 
dans le futur.</p>
<p>La table ci-dessous présente les caractères de contrôle pouvant être utilisés avec 
REBOL :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Character</p>
</b></td><td><b>
<p>Definition</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(null)" or #"@"</p>
</td><td>
<p>nul (zero)</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(line)", #"/" or, #"."</p>
</td><td>
<p>fin de ligne</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(tab)" or #"-"</p>
</td><td>
<p>tabulation horizontale</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(page)"</p>
</td><td>
<p>nouvelle page (et  page eject)</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(esc)"</p>
</td><td>
<p>escape</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(back)"</p>
</td><td>
<p>retour arrière (backspace)</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(del)"</p>
</td><td>
<p>delete</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"^"</p>
</td><td>
<p>caractére "caret"</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"^""</p>
</td><td>
<p>apostrophe</p>
</td></tr><tr class="md-cell" ><td>
<p>&#35;"(00)" to #"(FF)"</p>
</td><td>
<p>formes hexa des caractères</p>
</td></tr></table>
<p>
<p>
<h4 id="section-4.1.3">4.1.3 Création</h4>
<p>Les caractères peuvent être convertis depuis et vers d'autres types de données avec la 
fonction <b>to-char</b> :</p>
<pre>
probe to-char "a"
<span class="output">#"a"</span>
probe to-char "z"
<span class="output">#"z"</span>
</pre>
<p>Les caractères suivent le standard ASCII, et peuvent être 
construits en spécifiant leurs équivalents ASCII  :</p>
<pre>
probe to-char 65
<span class="output">#"A"</span>
probe to-char 52
<span class="output">#"4"</span>
probe to-char 52.3
<span class="output">#"4"</span>
</pre>
<p>Une autre méthode pour obtenir un caractère est de récupérer le premier caractère d'une 
chaîne :</p>
<pre>
probe first "ABC"
<span class="output">#"A"</span>
</pre>
<p>Alors que les caractères dans les chaînes ne sont sensibles à la casse, 
ils le deviennent lorsqu'ils sont sous forme de caractères individuels :</p>
<pre>
probe "a" = "A"    ; insensibles à la casse : MAJ = min
<span class="output">true</span>
probe #"a" = #"A"    ; sensibles à la casse :  MAJ &lt;&gt; min
<span class="output">false</span>
</pre>
<p>Cependant, dans la plupart des fonctions, lorsqu'ils sont utilisés, 
la comparaison n'est pas sensible à la casse à moins de spécifier cette option. 
Par exemple :</p>
<pre>
select [#"A" 1] #"a"
<span class="output">1</span>
select/case [#"A" 1] #"a"
<span class="output">none</span>
find "abcde" #"B"
<span class="output">"bcde"</span>
find/case "abcde" #"B"
<span class="output">none</span>
switch #"A" [#"a" [print true]]
<span class="output">true</span>
</pre>
<p>
<h4 id="section-4.1.4">4.1.4 Autres informations</h4>
<p>Utilisez <b>char?</b> pour déterminer si une valeur est de type <b>char!</b>.</p>
<pre>
probe char? "a"
<span class="output">false</span>
probe char? #"a"
<span class="output">true</span>
</pre>
<p>La fonction <b>form</b> retourne le caractère sans le symbole (#).</p>
<pre>
probe form #"A"
<span class="output">"A"</span>
</pre>
<p>La fonction <b>mold</b> renvoie le caractère avec le signe (#), les apostrophes (double quotes), 
et aussi les séquences d'échappement pour les caractères qui le nécessitent :</p>
<pre>
probe mold #"A"
<span class="output">{#"A"}</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.2">4.2 Date</h3>
<blockquote>
<p>
<h4 id="section-4.2.1">4.2.1 Concept</h4>
<p>Tout autour de la planète, les dates sont écrites dans divers formats. 
Malgré tout, la plupart des pays utilisent le format jour-mois-année (JJ-MM-AA). 
L'une des exceptions à cela sont les Etats-Unis, qui utilisent couramment 
le format mois-jour-année (MM-JJ-AA). <br />
Par exemple, une date écrite sous la forme 2/1/1999 est ambiguë. Le mois pourrait être 
interprété soit comme février soit comme janvier. Certains pays utilisent le trait d'union 
(-) comme séparateur, d'autres le symbole slash (/), et encore d'autres utilisent le point (.).</p>
<p>Et pour finir, les ordinateurs personnels utilisent souvent des dates dans le 
format ISO année-mois-jour (AA-MM-JJ).</p>
<p>
<h4 id="section-4.2.2">4.2.2 Format</h4>
<p>Le langage REBOL est flexible, et il permet au type de données date! d'être exprimé 
dans des formats divers. Par exemple, le premier jour de mars peut s'écrire sous l'un 
ou l'autre des formats suivants :</p>
<pre>
probe 1/3/1999
<span class="output">1-Mar-1999</span>
probe 1-3-1999
<span class="output">1-Mar-1999</span>
probe 1999-3-1  ;ISO format
<span class="output">1-Mar-1999</span>
</pre>
<p>L'année peut aller de 1 jusqu'à 9999. (<b>NdT</b> : si quelqu'un veut bien patienter jusque là 
pour voir s'il n'y a pas un bug ;-)).<br />
Les jours relatifs aux années bissextiles (le 29 février) n'existent que pour ces années-là.</p>
<pre>
probe 29-2-2000
<span class="output">29-Feb-2000</span>
probe 29-2-2004
<span class="output">29-Feb-2004</span>
probe 29-2-2002
<span class="output">** Syntax Error: Invalid date -- 29-2-2002
** Near: (line 1) probe 29-2-2002</span>
</pre>
<p>Les champs des dates peuvent être séparés avec le symbole "slash" (/) ou "tiret" (-). 
Les dates peuvent être écrites soit au format "année-mois-jour", soit au format "jour-mois-année" :</p>
<pre>
probe 1999-10-5
<span class="output">5-Oct-1999</span>
probe 1999/10/5
<span class="output">5-Oct-1999</span>
probe 5-10-1999
<span class="output">5-Oct-1999</span>
probe 5/10/1999
<span class="output">5-Oct-1999</span>
</pre>
<p>Parce que les formats de date internationaux ne sont pas beaucoup utilisés aux Etats-Unis, 
un nom de mois ou son abréviation peuvent aussi être utilisés :</p>
<pre>
probe 5/Oct/1999
<span class="output">5-Oct-1999</span>
probe 5-October-1999
<span class="output">5-Oct-1999</span>
probe 1999/oct/5
<span class="output">5-Oct-1999</span>
</pre>
<p>Quand l'année correspond au dernier champ, elle peut écrite avec 2 ou 4 chiffres :</p>
<pre>
probe 5/oct/99
<span class="output">5-Oct-1999</span>
probe 5/oct/1999
<span class="output">5-Oct-1999</span>
</pre>
<p>Cependant, il est préférable d'écrire l'année sur 4 chiffres.
En effet, des problèmes peuvent survenir sinon, lors de comparaison de dates ou 
en effectuant des opérations de tris.</p>
<p>Quand deux chiffres sont utilisés pour exprimer l'année, l'interprétation de 
celle-ci est relative à l'année en cours et est uniquement valide pour une période 
de 50 ans dans le passé ou dans le futur.</p>
<pre>
probe 28-2-66   ; fait référence à 1966
<span class="output">28-Feb-1966</span>
probe 12-Mar-20 ; fait référence à 2020
<span class="output">12-Mar-2020</span>
probe 11-3-45   ; fait référence à 2045, pas à 1945
<span class="output">11-Mar-2045</span>
</pre>
<p>Il est recommandé d'utiliser une année sur 4 chiffres afin d'éviter les problèmes potentiels. 
Pour représenter les dates dans le premier siècle (rarement fait puisque le calendrier Grégorien 
n'existait pas), utilisez des zéros supplémentaires pour représenter le siècle (comme dans 9-4-0029).</p>
<p>L'heure est séparée de la date par le symbole slash (/).
Le fuseau horaire est ajouté ensuite en utilisant les signes (+) ou (-) 
sans aucun espace. Les fuseaux horaires sont écrits sous forme de décalage horaire (plus ou moins) 
relativement à l'heure GMT. La résolution pour le fuseau horaire est d'une demi-heure. 
Si le décalage horaire est un nombre entier, on suppose qu'il s'agit d'heures :</p>
<pre>
probe 4/Apr/2000/6:00+8:00
<span class="output">4-Apr-2000/6:00+8:00</span>
probe 1999-10-2/2:00-4:00
<span class="output">2-Oct-1999/2:00-4:00</span>
probe 1/1/1990/12:20:25-6
<span class="output">1-Jan-1990/12:20:25</span>
</pre>
<p>Il ne peut y avoir d'espaces au sein d'une date. Par exemple, l'expression</p>
<pre>
10 - 5 - 99
</pre>
<p>sera être interprétée comme une soustraction, pas une date.</p>
<p>
<h4 id="section-4.2.3">4.2.3 Accéder aux données d'une variable date!</h4>
<p>Quelques raffinements peuvent être utilisés avec une valeur de type <b>date!</b> 
pour récupérer l'un ou l'autre des champs prédéfinis :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Raffinement</p>
</b></td><td><b>
<p>Description</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/day</b></p>
</td><td>
<p>retourne le jour.</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/month</b></p>
</td><td>
<p>retourne le mois.</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/year</b></p>
</td><td>
<p>retourne l'année.</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/julian</b></p>
</td><td>
<p>retourne le jour de l'année.</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/weekday</b></p>
</td><td>
<p>renvoie le jour dans la semaine (1-7/Mon-Sun).</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/time</b></p>
</td><td>
<p>retourne l'heure (si elle existe).</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/hour</b></p>
</td><td>
<p>retourne l'heure (si elle existe).</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/minute</b></p>
</td><td>
<p>retourne les minutes (si cette information existe).</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/second</b></p>
</td><td>
<p>renvoie les secondes (si cette information existe).</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/zone</b></p>
</td><td>
<p>renvoie le fuseau horaire (s'il existe).</p>
</td></tr></table>
<p>
<p>Voici comment ces raffinements fonctionnent :</p>
<pre>
some-date: 29-Feb-2000
probe some-date/day
<span class="output">29</span>
probe some-date/month
<span class="output">2</span>
probe some-date/year
<span class="output">2000</span>
days: ["Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun"]
probe pick days some-date/weekday
<span class="output">Tue</span>
</pre>
<p>Quand l'heure est fournie, les raffinements relatifs à l'heure peuvent être utilisés. 
Les raffinements <b>/hour</b>, <b>/minute</b> et <b>/second</b> peuvent être utilisés avec le raffinement <b>/time</b> 
qui isole les données horaires, afin de les manipuler :</p>
<pre>
lost-time: 29-Feb-2000/11:33:22.14-8:00
probe lost-time/time
<span class="output">11:33:22.14</span>
probe lost-time/time/hour
<span class="output">11</span>
probe lost-time/time/minute
<span class="output">33</span>
probe lost-time/time/second
<span class="output">22.14</span>
probe lost-time/zone
<span class="output">-8:00</span>
</pre>
<p>
<h4 id="section-4.2.4">4.2.4 Création</h4>
<p>Utilisez la fonction <b>to-date</b> pour convertir des valeurs en dates :</p>
<pre>
probe to-date "5-10-1999"
<span class="output">5-Oct-1999</span>
probe to-date "5 10 1999 10:30"
<span class="output">5-Oct-1999/10:30</span>
probe to-date [1999 10 5]
<span class="output">5-Oct-1999</span>
probe to-date [5 10 1999 10:30 -8:00]
<span class="output">5-Oct-1999/10:30-8:00</span>
</pre>
<div class="note"><p><b></b></p>
<p>Pour la conversion vers une date, l'année DOIT être spécifiée avec 4 chiffres.</p>
</div>
<p>Diverses opérations mathématiques peuvent être réalisées sur les dates :</p>
<pre>
probe 5-Oct-1999 + 1
<span class="output">6-Oct-1999</span>
probe 5-10-1999 - 10
<span class="output">25-Sep-1999</span>
probe 5-Oct-1999/23:00 + 5:00
<span class="output">6-Oct-1999/4:00</span>
</pre>
<p>
<h4 id="section-4.2.5">4.2.5 Autres informations</h4>
<p>Utilisez la fonction <b>date?</b> pour déterminer si une valeur appartient à ce type de données.</p>
<pre>
probe date? 5/1/1999
<span class="output">true</span>
</pre>
<p>La fonction <b>to-idate</b> renvoie la date sous forme d'une chaîne au format standard en vigueur sur Internet.</p>
<p>Le format de date pour Internet est : jour de la semaine, jour dans le mois, mois,  année, 
l'heure (sur 24 heures), et le décalage horaire vis-à-vis de l'heure GMT, soit :</p>
<pre>
probe to-idate now
<span class="output">Fri, 30 Jun 2000 14:42:26 -0700</span>
</pre>
<p>La fonction <b>now</b> renvoie la date et l'heure courante (au format long incluant le décalage horaire) :</p>
<pre>
probe now
<span class="output">30-Jun-2000/14:42:26-7:00</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.3">4.3 Logic</h3>
<blockquote>
<p>
<h4 id="section-4.3.1">4.3.1 Concept</h4>
<p>Le type de données <b>logic!</b> permet de représenter deux états : <b>true</b> ou <b>false</b>, c'est-à-dire : vrai ou faux.</p>
<p>Ce type de donnée est souvent utilisé pour des comparaison comme avec :</p>
<pre>
age: 100
probe age = 100
<span class="output">true</span>
time: 10:31:00
probe time &lt; 10:30
<span class="output">false</span>
str: "this is a string"
probe (length? str) &gt; 10
<span class="output">true</span>
</pre>
<p>Le type de données <b>logic!</b> est couramment utilisé avec des fonctions conditionnelles 
telles que <b>if</b>, <b>while</b>, et <b>until</b> :</p>
<pre>
if age = 100 [print "Centennial human"]
<span class="output">Centennial human</span>
while [time &gt; 6:30] [
    send person "Wake up!"
    wait [0:10]
]
</pre>
<p>Le complément d'une valeur logique est obtenue avec la fonction <b>not</b> :</p>
<pre>
there: place = "Ukiah" 
if not there [...]
</pre>
<p>
<h4 id="section-4.3.2">4.3.2 Format</h4>
<p>Normalement, les valeurs logiques sont récupérées à partir de la comparaison d'expression. 
Cependant, des mots peuvent être définis comme valeurs logiques et utilisés comme expressions logiques : 
"<b>on</b>" ou "<b>off</b>".</p>
<pre>
print-me: false
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
print-me: true
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
</pre>
<p>La valeur <b>false</b> n'est pas équivalente au nombre entier zéro, ni non plus 
à <b>none</b>. Cependant, dans les expressions conditionnelles, <b>false</b> et <b>none</b> ont le même effet :</p>
<pre>
print-me: none
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
</pre>
<p>N'importe quelle valeur assignée à un mot conduit au même 
effet que si vous aviez <b>true</b> :</p>
<pre>
print-me: "just a string"
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: 11-11-1999
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
</pre>
<p>Les mots suivants sont prédéfinis pour manipuler des valeurs logiques :</p>
<pre>
true
on     ;identique à true
yes    ;identique à true
false
off    ;identique à false
no     ;identique à false
</pre>
<p>Donc, au lieu de <b>true</b> et <b>false</b>, lorsque cela a du sens, les mots <b>on</b> et <b>off</b>, ou 
<b>yes</b> et <b>no</b> peuvent aussi être utilisés :</p>
<pre>
print-me: yes
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: no
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
print-me: on
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: off
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
</pre>
<p>
<h4 id="section-4.3.3">4.3.3 Création</h4>
<p>La fonction <b>to-logic</b> transforme des valeurs de type <b>integer!</b> ou <b>none!</b> 
en type de données <b>logic!</b> :</p>
<pre>
probe to-logic 0
<span class="output">false</span>
probe to-logic 200
<span class="output">true</span>
probe to-logic none
<span class="output">false</span>
probe to-logic []
<span class="output">true</span>
probe to-logic "a"
<span class="output">true</span>
probe to-logic none
<span class="output">false</span>
</pre>
<p>
<h4 id="section-4.3.4">4.3.4 Informations complémentaires</h4>
<p>La fonction <b>logic?</b> permet de savoir si la valeur testée est bien de ce type :</p>
<pre>
probe logic? 1
<span class="output">false</span>
probe logic? on
<span class="output">true</span>
probe logic? false
<span class="output">true</span>
</pre>
<p>Utilisez les fonctions <b>form</b>, <b>print</b>, et <b>mold</b> pour afficher une valeur <b>logic!</b> :</p>
<pre>
probe form true
<span class="output">true</span>
probe mold false
<span class="output">false</span>
print true
<span class="output">true</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.4">4.4 Money</h3>
<blockquote>
<p>
<h4 id="section-4.4.1">4.4.1 Concept</h4>
<p>Il existe divers symboles internationaux pour les valeurs monétaires.
Certains de ses symboles apparaissent avant le montant, et d'autres après.
Comme standard pour représenter des valeurs monétaires internationales, 
le langage REBOL utilise le format monétaire des États-Unis, mais permet aussi d'inclure des 
caractéristiques spécifiques.</p>
<p>
<h4 id="section-4.4.2">4.4.2 Format</h4>
<p>Le type de données <b>money!</b> utilise la notation en virgule flottante standardisée par l'IEEE, 
qui fournit une précision sur 15 chiffres, centimes inclus.</p>
<p>Le langage limite la longueur de la valeur à 64 caractères. Les valeurs qui sont en dehors 
(trop grandes ou trop petites) ou qui ne peuvent être représentées sur 64 caractères génèrent une erreur.</p>
<p>Les valeurs monétaires sont préfixées avec un indicateur (optionnel) pour la devise, 
suivies d'un signe dollar ($).
Un signe plus (+) ou moins (-) peut apparaître, immédiatement suivi par le premier caractère 
(indication de la devise, ou signe dollar), afin d'indiquer le signe.</p>
<pre>
$123
-$123
$123.45
US$12
US$12.34
-US$12.34
$12,34
-$12,34
DEM$12,34
</pre>
<p>Pour simplifier la lisibilité des grands nombres, et les mettre en morceaux lisibles, 
une simple quote (`) peut être placée n'importe où entre deux chiffres à l'intérieur du 
nombre, mais pas avant le nombre.</p>
<pre>
probe $1'234.56
<span class="output">$1234.56</span>
probe $1'234'567,89
<span class="output">$1234567.89</span>
</pre>
<p>N'utilisez pas de virgules ou de points pour couper des valeurs monétaires, car ces deux caractères 
représentent le séparateur décimal. 
Le datatype <b>money!</b> est un type de données hybride. Conceptuellement, le montant est un scalaire. 
Cependant, parce que la désignation de la devise est stockée sous forme de chaîne, le type de données <b>money!</b> 
possède deux éléments :</p>
<table cellspacing="6" border="0" width="95%">
<tr><td width="20">&nbsp;</td><td valign="top" width="80"><b>string!</b></td><td valign="top">l'élément désignant le type de devise (USD, EUR, YEN, etc.), qui peut avoir 3 caractères maximum. 
</td></tr>
<tr><td width="20">&nbsp;</td><td valign="top" width="80"><b>decimal!</b></td><td valign="top">le montant
</td></tr>
</table>
<p>Pour illustrer ceci, la valeur monétaire suivante est préfixée avec la chaîne USD pour "dollar US" :</p>
<pre>
my-money: USD$12345.67
</pre>
<p>Voici ces deux composantes :</p>
<pre>
probe first my-money
<span class="output">USD</span>
probe second my-money
<span class="output">12345.67</span>
probe pick my-money 3       ; seulement deux éléments
<span class="output">none</span>
</pre>
<p>Si aucun indicateur de devise n'est employé, l'élément qui y fait référence est vide.</p>
<pre>
my-money: $12345.67

probe first my-money
<span class="output">""</span>
probe second my-money
<span class="output">12345.67</span>
</pre>
<p>Les devises internationales peuvent être spécifiées avec l'indicateur de devises, comme ici :</p>
<pre>
my-money: DKM$12'345,67

probe first my-money
<span class="output">DKM</span>
probe second my-money
<span class="output">12345.67</span>
</pre>
<p>
<h4 id="section-4.4.3">4.4.3 Création</h4>
<p>Utilisez la fonction <b>to-money</b> pour transformer des valeurs de type <b>string!</b>, <b>integer!</b>, <b>decimal!</b>, 
ou <b>block!</b> en valeurs de type <b>money!</b>.</p>
<pre>
probe to-money 123
<span class="output">$123.00</span>
probe to-money "123"
<span class="output">$123.00</span>
probe to-money 12.34
<span class="output">$12.34</span>
probe to-money [DEM 12.34]
<span class="output">DEM$12.34</span>
probe to-money [USA 12 34]
<span class="output">USA$12.34</span>
</pre>
<p>Les valeurs de type <b>money!</b> peuvent être ajoutées, 
soustraites, et comparées avec d'autres monnaies de la même devise. 
Une erreur se produit si des devises différentes sont mélangées pour ce genre d'opérations 
(les conversions automatiques ne sont pas prévues actuellement).</p>
<pre>
probe $100 + $10
<span class="output">$110.00</span>
probe $100 - $50
<span class="output">$50.00</span>
probe equal? DEM$100.11 DEM$100.11
<span class="output">true</span>
</pre>
<p>Les valeurs monétaires peuvent être multipliées et divisées avec des nombres entiers ou décimaux.</p>
<p>Les valeurs monétaires peuvent aussi être divisées par d'autres valeurs monétaires, le résultat 
étant un nombre entier ou décimal.</p>
<pre>
probe $100 + 11
<span class="output">$111.00</span>
probe $100 / 4
<span class="output">$25.00</span>
probe $100 * 5
<span class="output">$500.00</span>
probe $100 - 20.50
<span class="output">$79.50</span>
probe 10 + $1.20
<span class="output">$11.20</span>
probe 10 - $0.25
<span class="output">$9.75</span>
probe $10 / .50
<span class="output">$20.00</span>
probe 10 * $0.75
<span class="output">$7.50</span>
</pre>
<p>
<h4 id="section-4.4.4">4.4.4 Autres informations</h4>
<p>Vous pouvez utilisez <b>money?</b> pour savoir si 
une valeur est de type de données <b>money!</b>.</p>
<pre>
probe money? USD$12.34
<span class="output">true</span>
</pre>
<p>Utilisez les fonctions <b>form</b>, <b>print</b>, et <b>mold</b> avec un argument de type <b>money!</b> pour afficher une 
valeur monétaire, avec l'indicateur de devise et le signe dollar ($), sous forme d'un nombre décimal 
avec une précision à deux chiffres.</p>
<pre>
probe form USD$12.34
<span class="output">USD$12.34</span>
probe mold USD$12.34
<span class="output">USD$12.34</span>
print USD$12.34
<span class="output">USD$12.34</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.5">4.5 None</h3>
<blockquote>
<p>
<h4 id="section-4.5.1">4.5.1 Concept</h4>
<p>Le datatype <b>none!</b> contient une unique valeur qui représente "rien" ou "aucune valeur". 
Le concept de <b>none</b> est différent de celui d'un bloc vide, d'une chaîne vide, 
ou d'un caractère nul. C'est une valeur qui représente une <i>non-existence</i>.</p>
<p>Une valeur <b>none!</b> peut être renvoyée par des fonctions très différentes, en particulier 
celles qui sont utilisées avec des séries (par exemple, <b>pick</b> et <b>find</b>).</p>
<p>Le mot REBOL <b>none</b> est défini comme faisant partie du type de donnée <b>none!</b> et il 
fait référence à une valeur <b>none!</b>. Le mot <b>none</b> n'est pas équivalent à <b>zero</b> ou à <b>false</b>.</p>
<p>Cependant, <b>none</b> va être interprété comme <b>false</b> par beaucoup de fonctions. 
Une valeur <b>none!</b> autorise beaucoup d'usages comme par exemple servir de valeur de retours à des fonctions relatives aux 
séries comme <b>pick</b>, <b>find</b>, et <b>select</b> :</p>
<pre>
if (pick series 30) = none [...]
</pre>
<p>Dans des bases de données, une valeur <b>none</b> peut être un moyen de remplacer des valeurs manquantes :</p>
<pre>
email-database: [
    "Bobby" bob@rebol.com 40
    "Linda" none 23
    "Sara"  sara@rebol.net 33
]
</pre>
<p><b>None</b> peut aussi être utilisée comme valeur logique :</p>
<pre>
secure none
</pre>
<p>
<h4 id="section-4.5.2">4.5.2 Format</h4>
<p>Le mot <b>none</b> est prédéfini pour manipuler une valeur de type <b>none!</b>.
Bien que <b>none</b> ne soit pas équivalent à <b>zero</b> ou <b>false</b>, elle est valide dans des expressions conditionnelles 
et a le même effet que <b>false</b> :</p>
<pre>
probe find "abcd" "e"
<span class="output">none</span>
if find "abcd" "e" [print "found"]
</pre>
<p>
<h4 id="section-4.5.3">4.5.3 Création</h4>
<p>
<h4 id="section-4.5.4">4.5.4 Autres informations</h4>
<p>Il est possible d'utiliser <b>none?</b> pour déterminer si une valeur est ou non du type 
<b>none!</b>.</p>
<pre>
print none? 1
<span class="output">false</span>
print none? find [1 2 3] 4
<span class="output">true</span>
</pre>
<p>Les fonctions <b>form</b>, <b>print</b> et <b>mold</b> retournent la valeur <b>none</b> 
lorsqu'un argument <b>none</b> leur est fourni :</p>
<pre>
probe form none
<span class="output">none</span>
probe mold none
<span class="output">none</span>
print none
<span class="output">none</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.6">4.6 Pair</h3>
<blockquote>
<p>
<h4 id="section-4.6.1">4.6.1 Concept</h4>
<p>Le type de données <b>pair!</b> est utilisé pour indiquer des coordonnées dans l'espace, comme par exemple des 
positions à l'écran. Les "pairs" peuvent être utilisées aussi pour définir des tailles en plus des positions.</p>
<p>Les valeurs de type <b>pair!</b> sont en particulier utilisées dans REBOL/View.</p>
<p>
<h4 id="section-4.6.2">4.6.2 Format</h4>
<p>Une valeur de type <b>pair!</b> est définie par deux nombres entiers séparés par un caractère "x".</p>
<pre>
100x50

1024x800

-50x200
</pre>
<p>
<h4 id="section-4.6.3">4.6.3 Création</h4>
<p>Utilisez la fonction <b>to-pair</b> pour transformer des blocs ou 
des chaînes de caractères :</p>
<pre>
p: to-pair "640x480" 
probe p
<span class="output">640x480</span>
p: to-pair [800 600] 
probe p
<span class="output">800x600</span>
</pre>
<p>
<h4 id="section-4.6.4">4.6.4 Autres</h4>
<p>La fonction <b>pair?</b> permet de savoir si la valeur qui lui est fournie en argument 
est bien de ce type de données :</p>
<pre>
probe pair? 400x200
<span class="output">true</span>
probe pair? pair
<span class="output">true</span>
</pre>
<p>Les pairs peuvent être utilisées avec la plupart des opérateurs mathématiques 
associés aux nombres entiers :</p>
<pre>
100x200 + 10x20

10x20 * 2x4

100x30 / 10x3

100x100 * 3

10x10 + 3
</pre>
<p>Il est possible d'extraire des valeurs de type <b>pair!</b> leurs composantes individuelles :</p>
<pre>
pair: 640x480
probe first pair
<span class="output">640</span>
probe second pair
<span class="output">480</span>
</pre>
<p>Toutes les valeurs de type <b>pair!</b> supportent les raffinements <b>/x</b> et <b>/y</b>. 
Ces raffinements permettent la consultation et la manipulation, de façon spécifique, des coordonnées x et y.</p>
<p>Pour récupérer individuellement chaque coordonnée :</p>
<pre>
probe pair/x
<span class="output">640</span>
probe pair/y
<span class="output">480</span>
</pre>
<p>Pour modifier l'une ou l'autre des coordonnées :</p>
<pre>
pair/x: 800
pair/y: 600
probe pair
<span class="output">800x600</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.7">4.7 Raffinement</h3>
<blockquote>
<p>
<h4 id="section-4.7.1">4.7.1 Concept</h4>
<p>Les raffinements sont des "modificateurs", comme peuvent l'être les adjectifs 
utilisés dans les langages humains. Un raffinement indique une variation dans l'usage, ou une 
extension dans le sens, d'une fonction, d'un objet, d'un nom de fichier, d'une URL, ou d'un chemin (path). 
Les raffinements sont toujours symboliques dans leurs valeurs.</p>
<p>Ils sont utilisés dans les fonctions :</p>
<pre>
block: [1 2]
append/only block [3 4]
</pre>
<p>mais aussi avec les objets :</p>
<pre>
print system/version
</pre>
<p>ou les fichiers :</p>
<pre>
dir: %docs/core
print read dir/file.txt
</pre>
<p>ou encore les urls :</p>
<pre>
site: http://www.rebol.com
print read site/index.html
</pre>
<p>
<h4 id="section-4.7.2">4.7.2 Format</h4>
<p>Les raffinements sont formés par l'association d'un slash {/} et d'un mot REBOL valide (voir la section 
sur les mots ci-dessous). Par exemple :</p>
<pre>
/only
/test1
/save-it
</pre>
<p>Les raffinements sont habituellement concaténés à d'autres mots, 
comme dans le cas de :</p>
<pre>
port: open/binary file
</pre>
<p>Mais les raffinements peuvent aussi être écrits seuls, comme lorsqu'ils apparaissent 
dans la spécification d'une fonction :</p>
<pre>
save-data: function [file data /limit /reload] ...
</pre>
<p>
<h4 id="section-4.7.3">4.7.3 Création</h4>
<p>Les raffinements peuvent aussi être créés directement dans le code source :</p>
<pre>
/test
</pre>
<p>ou être composés avec la fonction <b>to-refinement</b> :</p>
<pre>
probe to-refinement "test"
<span class="output">/test</span>
</pre>
<p>
<h4 id="section-4.7.4">4.7.4 Et aussi...</h4>
<p>Pour tester une valeur, la fonction <b>refinement?</b> est utilisable :</p>
<pre>
probe refinement? /test
<span class="output">true</span>
probe refinement? 'word
<span class="output">false</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.8">4.8 Time</h3>
<blockquote>
<p>
<h4 id="section-4.8.1">4.8.1 Concept</h4>
<p>Le langage REBOL supporte une expression standard du temps en heures,  
minutes, secondes, jusqu'à la milliseconde et plus. Des valeurs de temps négatives ou positives 
sont permises.</p>
<p>Le type de donnée <b>time!</b> utilise un affichage relatif, plutôt que l'heure absolue.</p>
<p>Par exemple, 10:30 représente 10 heures et 30 minutes, plutôt que 10:30 A.M. ou P.M.</p>
<p>
<h4 id="section-4.8.2">4.8.2 Format</h4>
<p>Les valeurs de type <b>time!</b> se présentent sous la forme d'un ensemble de nombres entiers 
séparés par le symbole (:). 
Les heures et les minutes sont nécessaires, mais les secondes sont optionnelles. : 
Pour chaque champ (heure:minutes:secondes), les zéros additionnels sont ignorés</p>
<pre>
10:30
0:00
18:59
23:59:50
8:6:20
8:6:2
</pre>
<p>Les valeurs de minutes et de secondes peuvent être supérieures à 60.</p>
<p>Ces valeurs plus grandes que 60 sont automatiquement converties. Ainsi, 
0:120:00 est la même chose que 2:00.</p>
<pre>
probe 00:120:00
<span class="output">2:00</span>
</pre>
<p>Les diziémes ou centiémes de seconde sont définis en utilisant 
le séparateur décimal dans le champ des secondes. (Utilisez un point ou une virgule comme séparateur décimal).</p>
<p>Les champs heures et minutes deviennent optionnels quand un nombre décimal est fourni. 
Les éléments inférieurs à la seconde sont encodés en nanosecondes, soit 
au milliardième de seconde :</p>
<pre>
probe 32:59:29.5
32:59:29.5
probe 1:10,25
0:01:10.25
probe 0:0.000000001
0:00:00.000000001
probe 0:325.2
0:05:25.2
</pre>
<p>Les valeurs de type <b>time!</b> peuvent être suivies par les chaînes AM ou PM, mais AUCUN n'espace n'est permis dans ce cas.</p>
<p>L'ajout de la chaîne PM revient à ajouter 12 heures à l'heure indiquée :</p>
<pre>
probe 10:20PM
22:20
probe 3:32:20AM
3:32:20
</pre>
<p>Les valeurs <b>time!</b> retournées se présentent avec un format standard en heures, minutes, secondes, 
et fractions de secondes, indépendamment de la façon dont elles ont été saisies :</p>
<pre>
probe 0:87363.21
24:16:03.21
</pre>
<p>
<h4 id="section-4.8.3">4.8.3 Accès aux champs</h4>
<p>Les valeurs de type <b>time!</b> possèdent trois raffinements qui servent à retourner des informations 
spécifiques :</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Raffinement</p>
</b></td><td><b>
<p>Description</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/hour</b></p>
</td><td>
<p>Renvoie la valeur de l'heure</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/minute</b></p>
</td><td>
<p>Renvoie la valeur pour les minutes</p>
</td></tr><tr class="md-cell" ><td>
<p><b>/second</b></p>
</td><td>
<p>Renvoie la valeur des secondes</p>
</td></tr></table>
<p>
<p>Voici comment utiliser ces raffinements :</p>
<pre>
lapsed-time: 91:32:12.14
probe lapsed-time/hour
<span class="output">91</span>
probe lapsed-time/minute
<span class="output">32</span>
probe lapsed-time/second
<span class="output">12.14</span>
</pre>
<p>Les données horaires avec des fuseaux horaires peuvent uniquement 
être utilisées dans des valeurs de type <b>date!</b>.</p>
<p>
<h4 id="section-4.8.4">4.8.4 Création</h4>
<p>Les valeurs <b>time!</b> peuvent être créées avec la fonction <b>to-time</b> :</p>
<pre>
probe to-time "10:30"
<span class="output">10:30</span>
probe to-time [10 30]
<span class="output">10:30</span>
probe to-time [0 10 30]
<span class="output">0:10:30</span>
probe to-time [10 30 20.5]
<span class="output">10:30:20.5</span>
</pre>
<p>Dans les exemples précédents, les valeurs ne sont pas évaluées. 
Pour évaluer des valeurs comme des expressions mathématiques, utilisez la fonction <b>reduce</b>.</p>
<pre>
probe to-time reduce [10 30 + 5]
<span class="output">10:35</span>
</pre>
<p>Dans les différentes opérations mathématiques mettant en oeuvre des 
valeurs de type <b>time!</b>, celles-ci ou les nombres entiers et décimaux impliqués sont manipulés ainsi :</p>
<pre>
probe 10:30 + 1
<span class="output">10:30:01</span>
probe 10:00 - 10
<span class="output">9:59:50</span>
probe 0:00 - 10
<span class="output">-0:00:10</span>
probe 5:10 * 3
<span class="output">15:30</span>
probe 0:0:0.000000001 * 1'500'600
<span class="output">0:00:00.0015006</span>
probe 8:40:20 / 4
<span class="output">2:10:05</span>
probe 8:40:20 / 2:20:05
<span class="output">3</span>
probe 8:40:20 // 4:20
<span class="output">0:00:20</span>
</pre>
<p>
<h4 id="section-4.8.5">4.8.5 Autres informations</h4>
<p>La fonction <b>time?</b> permet de savoir si son argument a pour datatype <b>time?</b> :</p>
<pre>
probe time? 10:30
<span class="output">true</span>
probe time? 10.30
<span class="output">false</span>
</pre>
<p>Utilisez la fonction <b>now</b> avec le raffinement <b>/time</b> 
pour retourner la date et l'heure courante :</p>
<pre>
print now/time
<span class="output">14:42:15</span>
</pre>
<p>La fonction <b>wait</b> est utilisée pour attendre quelque chose, une certain durée, ou un port, ou les deux. 
Si la valeur est de type <b>time!</b>, <b>wait</b> permet une temporisation égale au temps indiqué. 
Si la valeur est de type <b>date!/time!</b>, la fonction <b>wait</b> permet une temporisation jusqu'à la date et 
l'heure indiquée. <br />
Si la valeur est de type <b>integer!</b> ou <b>decimal!</b>, <b>wait</b> permet d'attendre le nombre de secondes indiqué.</p>
<p>Si la valeur est un port, la fonction <b>wait</b> attendra un événement sur ce port.</p>
<p>Si un bloc est fourni en argument à <b>wait</b>, l'attente se fera pour chacun des 
arguments (ports ou valeurs de temps) indiqués. 
Si un événement s'est produit sur un port, <b>wait</b> retourne ce port, ou retourne none si 
un time-out s'est produit. Par exemple :</p>
<pre>
probe now/time
<span class="output">14:42:16</span>
wait 0:00:10
probe now/time
<span class="output">14:42:26</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.9">4.9 Tuple</h3>
<blockquote>
<p>
<h4 id="section-4.9.1">4.9.1 Concept</h4>
<p>Il est courant de représenter des numéros de versions, des adresses Internet, ou encore des valeurs 
de couleurs (RGB) sous la forme d'une séquence de trois ou quatre nombres entiers. 
Ces types de valeurs sont appelées des tuples (<b>tuple!</b>) (comme dans quin<b>tuple</b>) 
et sont représentées sous forme d'entiers séparés par des points.</p>
<pre>
1.3.0 2.1.120 1.0.2.32     ; version
199.4.80.250 255.255.255.0 ; adresse ou masque réseau
0.80.255 200.200.60        ; couleurs en RGB (rouge/vert/bleu)
</pre>
<p>
<h4 id="section-4.9.2">4.9.2 Format</h4>
<p>Chaque entier dans une valeur de type <b>tuple!</b> peut être comprise entre 0 et 255. 
Les nombres entiers négatifs génèrent une erreur. De trois à dix entiers peuvent être spécifiés dans un tuple.</p>
<p>Dans le cas où seulement deux entiers sont donnés, il doit y avoir au moins <i>deux</i> points, 
sinon la valeur sera assimilée à un nombre décimal.</p>
<pre>
probe 1.2     ; décimal
<span class="output">1.2</span>
probe type? 1.2
<span class="output">decimal!</span>
probe 1.2.3   ; un tuple
<span class="output">1.2.3</span>
probe 1.2.    ; un autre tuple
<span class="output">1.2.0</span>
probe type? 1.2.
<span class="output">tuple!</span>
</pre>
<p>
<h4 id="section-4.9.3">4.9.3 Création</h4>
<p>Utilisez la fonction <b>to-tuple</b> pour convertir des données en tuple :</p>
<pre>
probe to-tuple "12.34.56"
<span class="output">12.34.56</span>
probe to-tuple [12 34 56]
<span class="output">12.34.56</span>
</pre>
<p>
<h4 id="section-4.9.4">4.9.4 Et aussi</h4>
<p>La fonction <b>tuple?</b> permet de déterminer si une valeur est ou non du type <b>tuple!</b>.</p>
<pre>
probe tuple? 1.2.3.4
<span class="output">true</span>
</pre>
<p>Utilisez la fonction <b>form</b> pour afficher un tuple sous la forme d'une chaîne de caractères :</p>
<pre>
probe form 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>
<p>La fonction <b>mold</b> permet de convertir un tuple en chaîne de caractère, 
mais de façon à ce que celle-ci soit récupérable en tant que tuple :</p>
<pre>
probe mold 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>
<p>La fonction <b>print</b> affiche le tuple sur la sortie standard :</p>
<pre>
print 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>
</blockquote>
<p>
<h3 id="section-4.10">4.10 Words</h3>
<blockquote>
<p>
<h4 id="section-4.10.1">4.10.1 Concept</h4>
<p>Les mots (words) sont les symboles utilisés par REBOL. Un mot peut être ou non une variable, selon la façon dont 
il est utilisé. Les mots sont souvent utilisés comme symboles.</p>
<p>REBOL n'a pas de mots clés, il n'y a pas de restrictions sur les mots utilisés et la façon dont ils sont 
utilisés.</p>
<p>Par exemple, vous pouvez définir votre propre fonction appelée <b>print</b> et vous en servir à 
la place de la fonction prédéfinie dans le langage.</p>
<p>Il y a quatre formats différents pour l'utilisation des mots, selon l'opération qui est requise.</p>
<table class="md-table" border=1 cellspacing="1" cellpadding="4" >
        <tr class="md-header"><td><b>
<p>Action</p>
</b></td><td><b>
<p>Type de Mot</p>
</b></td><td><b>
<p>Type de Test</p>
</b></td><td><b>
<p>Conversion</p>
</td></tr><tr class="md-cell" ><td>
<p>word:</p>
</td><td>
<p>set-word!</p>
</td><td>
<p>set-word?</p>
</td><td>
<p>to-set-word</p>
</td></tr><tr class="md-cell" ><td>
<p>&#58;word</p>
</td><td>
<p>get-word!</p>
</td><td>
<p>get-word?</p>
</td><td>
<p>to-get-word</p>
</td></tr><tr class="md-cell" ><td>
<p>word</p>
</td><td>
<p>word!</p>
</td><td>
<p>word?</p>
</td><td>
<p>to-word</p>
</td></tr><tr class="md-cell" ><td>
<p>'word</p>
</td><td>
<p>lit-word!</p>
</td><td>
<p>lit-word?</p>
</td><td>
<p>to-lit-word</p>
</td></tr></table>
<p>
<p>
<h4 id="section-4.10.2">4.10.2 Format</h4>
<p>Les mots sont composés de caractères alphabétiques, de nombres, et de n'importe lequel des caractères suivants :</p>
<pre>
? ! . ' + - * &amp; | = _ ~
</pre>
<p>Un mot ne peut pas commencer par un nombre, et il existe aussi quelques restrictions sur les mots 
qui pourraient être interprétés comme des nombres. Par exemple, -1 et +1 sont des nombres, pas des mots.
La fin d'un mot est marquée par un espace, un caractère de fin de ligne, ou l'un des caractères suivants :</p>
<pre>
[ ] ( ) { } " : ; /
</pre>
<p>Par ailleurs, les crochets d'un bloc ne sont pas compris dans un mot :</p>
<pre>
[test]
</pre>
<p>Les caractères suivants ne sont pas autorisés dans des mots :</p>
<pre>
@ # $ % ^ ,
</pre>
<p>Les mots peuvent être de n'importe quelle longueur, mais ne peuvent pas dépasser une ligne.</p>
<pre>
this-is-a-very-long-word-used-as-an-example
</pre>
<p>Voici quelques exemples de mots :</p>
<pre>
Copy print test

number?  time?  date!

image-files  l'image

++ -- == +-

***** *new-line*

left&amp;right left|right
</pre>
<p>Le langage REBOL n'est pas sensible à la casse des caractères. Les mots suivants :</p>
<pre>
blue

Blue

BLUE
</pre>
<p>font tous référence au même mot.</p>
<p>La casse des caractères est préservée lorsque le mot est affiché. 
Les mots peuvent être réutilisés. La signification d'un mot dépend de son contexte, de sorte qu'un 
mot peut être réutilisé dans différents contextes.</p>
<p>Vous pouvez réutiliser n'importe quel mot, même les mots REBOL prédéfinis. 
Par exemple, le mot REBOL <b>if</b> peut être réutilisé dans votre code différemment de la façon 
dont l'interpréteur REBOL l'utilise.</p>
<p>
<h4 id="section-4.10.3">4.10.3 Création</h4>
<p>La fonction <b>to-word</b> convertit son argument en une valeur de type <b>word!</b>.</p>
<pre>
probe to-word "test"
<span class="output">test</span>
</pre>
<p>La fonction <b>to-set-word</b> convertit des valeurs en valeurs de type <b>set-word!</b> (mot défini).</p>
<pre>
probe make set-word! "test"
<span class="output">test:</span>
</pre>
<p>La fonction <b>to-get-word</b> renvoie des valeurs de type <b>to-get-word!</b>.</p>
<pre>
probe to-get-word "test"
<span class="output">:test</span>
</pre>
<p>La fonction <b>to-lit-word</b> renvoie des valeurs de type <b>lit-word!</b> (mot littéral).</p>
<pre>
probe to-lit-word "test"
<span class="output">'test</span>
</pre>
<p>
<h4 id="section-4.10.4">4.10.4 Autres informations</h4>
<p>Utilisez les fonctions <b>word?</b>, <b>set-word?</b>, <b>get-word?</b>, et <b>lit-word?</b> pour tester 
le datatype :</p>
<pre>
probe word? second [1 two "3"]
<span class="output">true</span>
if set-word? first [word: 10] [print "it is set"]
<span class="output">it is set</span>
probe get-word? second [pr: :print]
<span class="output">true</span>
probe lit-word? first ['foo bar]
<span class="output">true</span>
</pre>
</blockquote><br><br><hr><br><center><span class="tail">Updated 8-Apr-2005 - <a href="http://www.rebol.com">Copyright REBOL Technologies</a> - Formatted with MakeDoc2 - Translation by Philippe Le Goff</span></center><blockquote>
</blockquote>
</p>
</td></tr>
</table>
</center>


<map name="bar-map">
<area shape="rect" coords="0,0,150,28"   href="http://www.rebol.com" alt="REBOL.com">
<area shape="rect" coords="175,0,275,28" href="http://www.rebol.com/docs.html" alt="Documents">
<area shape="rect" coords="285,0,365,28" href="http://www.rebol.com/docs/core23/rebolcore.html" alt="Manual">
<area shape="rect" coords="375,0,445,28" href="http://www.rebol.com/docs/dictionary.html" alt="Dictionary">
<area shape="rect" coords="452,0,500,28" href="http://www.rebol.com/library.html" alt="Library">
<area shape="rect" coords="510,0,575,28" href="http://www.rebol.com/feedback.html" alt="Feedback">
</map>

</body>
</html>